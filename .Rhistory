transitions=c("HIVTest_result","New_infection"))+
event(name="HIVTest_result",
options=c("positive","none"),
probs=c("pTestpositive","#"),
transitions=c("get_conf_BT","New_infection"))+
event(name="get_conf_BT",
options=c("Yes","none"),
probs=c("fUseBT","#"),
transitions=c("Conf_BT_result","New_infection"))+
event(name="Conf_BT_result",
options=c("positive","none"),
probs=c("pTestpositive_BT","#"),
transitions=c("receiveART","New_infection"))+
event(name="receiveART",
options=c("Yes","none"),
probs=c("fHIV_diagART", "#"),
transitions=c("HIVdiag_ART", "HIVdiag_NoART"))+
event(name="New_infection",
options=c("Yes","none"),
probs=c("pNew_infection","#"),
transitions=c("HIVacute","Progress"))+ #"HIVchronic"
event(name="Progress",
options=c("toHIVchronic","toAIDS","none"),
probs=c("pProgressToHIVchronic","pProgressToAIDS","#"),
transitions=c("HIVchronic","AIDS","leave_curr_state"))+
event(name="leave_curr_state",
options=c("none","toOffART","toOnART"),
probs=c("#","foff_ART","fGo_on_ART"),
transitions=c("curr_state","HIVdiag_NoART","HIVdiag_ART")) +
payoffs(names = c("cost", "utility", "compute_le", "temp"),
discount_rates=c((1 + 0.015)^(1/12) - 1,(1 + 0.015)^(1/12) - 1,(1 + 0.015)^(1/12) - 1, 0)) #0.015
fUseBT <- function(pUseBT){
pUseBT
}
temp <- function(leave_curr_state){
ifelse(leave_curr_state=="toOffART", 1,  0)
}
mytwig
event(name="Progress",
options=c("toHIVchronic","toAIDS","none"),
probs=c("pProgressToHIVchronic","pProgressToAIDS","leftover"),
transitions=c("HIVchronic","AIDS","leave_curr_state"))+
event(name="leave_curr_state",
options=c("none","toOffART","toOnART"),
probs=c("leftover","foff_ART","fGo_on_ART"),
transitions=c("curr_state","HIVdiag_NoART","HIVdiag_ART")) +
payoffs(names = c("cost", "utility", "compute_le", "temp"),
discount_rates=c((1 + 0.015)^(1/12) - 1,(1 + 0.015)^(1/12) - 1,(1 + 0.015)^(1/12) - 1, 0)) # leftover0.015
n_cycles_acute <-3
mytwig <- twig()+
decisions(names = c("HIVST","Usualcare"))+
states(names=c("HIVneg","HIVacute","HIVchronic","HIVdiag_ART","HIVdiag_NoART","AIDS","Dead"),
init_probs=c(pHIVneg,pHIVacute,1-pHIVneg-pHIVacute,0,0,0,0),
max_cycles=c(1,n_cycles_acute,1,1,1,1,1))+ #inserted a 3 for the tunnel state
event(name="Alive",
options=c("Yes","none"),
probs=c("leftover","pDie"),
transitions=c("HIV_testing","Dead"))+
event(name="HIV_testing",
options=c("Yes","none"),
probs=c("pTest","leftover"),
transitions=c("HIVTest_result","New_infection"))+
event(name="HIVTest_result",
options=c("positive","none"),
probs=c("pTestpositive","leftover"),
transitions=c("get_conf_BT","New_infection"))+
event(name="get_conf_BT",
options=c("Yes","none"),
probs=c("fUseBT","leftover"),
transitions=c("Conf_BT_result","New_infection"))+
event(name="Conf_BT_result",
options=c("positive","none"),
probs=c("pTestpositive_BT","leftover"),
transitions=c("receiveART","New_infection"))+
event(name="receiveART",
options=c("Yes","none"),
probs=c("fHIV_diagART", "leftover"),
transitions=c("HIVdiag_ART", "HIVdiag_NoART"))+
event(name="New_infection",
options=c("Yes","none"),
probs=c("pNew_infection","leftover"),
transitions=c("HIVacute","Progress"))+ #"HIVchronic"
event(name="Progress",
options=c("toHIVchronic","toAIDS","none"),
probs=c("pProgressToHIVchronic","pProgressToAIDS","leftover"),
transitions=c("HIVchronic","AIDS","leave_curr_state"))+
event(name="leave_curr_state",
options=c("none","toOffART","toOnART"),
probs=c("leftover","foff_ART","fGo_on_ART"),
transitions=c("curr_state","HIVdiag_NoART","HIVdiag_ART")) +
payoffs(names = c("cost", "utility", "compute_le", "temp"),
discount_rates=c((1 + 0.015)^(1/12) - 1,(1 + 0.015)^(1/12) - 1,(1 + 0.015)^(1/12) - 1, 0)) # leftover0.015
fUseBT <- function(pUseBT){
pUseBT
}
temp <- function(leave_curr_state){
ifelse(leave_curr_state=="toOffART", 1,  0)
}
#FUNCTIONS so that the probabilities change based on each health state. Using test is a function of decision, pTestpositive are a function of decision and state
#It is a function of decision and the probability changes based on Usualcare vs HIVST and state since it is annual testing
#pUseSelfTest <- function(decision, cycle){
#if (decision == "HIVST") pUseHIVST else pOppScreen}
pTest <- function(decision, cycle, pHIVOppScreen, rr_HIVST_uptake) {
pUseHIVST = pHIVOppScreen*rr_HIVST_uptake #pHIVOppScreen*HIVST_multiplier, #pUseHIVST = 0.80, #0.45 #probability of using HIVST #0.45
pOppScreen= pHIVOppScreen #0.11, #0.30, #0.30 #probability of opportunistic screening with Usual Care #0.30
# Check if cycle minus 2 is divisible by 12 and vectorize the decision-based output
test_values <- ifelse((cycle - 2) %% 12 == 0,
ifelse(decision == "HIVST", pUseHIVST, pOppScreen),
0)
return(test_values)
}
#pTest <- function(decision, cycle){
#  if (!((cycle-2) %% 12))
#  {
#   if (decision == "HIVST") pUseHIVST else pOppScreen
#} else {
#    0
#}
#}
#Function for HIVST positive based on health state and decision HIVST vs Usual Care.
#Function for HIVST positive based on health state and decision HIVST vs Usual Care.
pTestpositive <- function(decision, state, specHIVST, sensHIVST, specELISA, sensELISA) {
ifelse(decision == "HIVST",
ifelse(state == "HIVneg", 1 - specHIVST,
ifelse(state %in% c("HIVacute", "HIVchronic"), sensHIVST, 0)),
ifelse(state == "HIVneg", 1 - specELISA,
ifelse(state %in% c("HIVacute", "HIVchronic"), sensELISA, 0))
)
}
#Function for Blood test positive based on health state
pTestpositive_BT <- function(state, specBT, sensBT) {
ifelse(state == "HIVneg", 1 - specBT, ifelse(state %in% c("HIVacute", "HIVchronic"), sensBT, 0))
}
#Function for New infection based on health states
pNew_infection <- function(state, incidenceHIV) {
ifelse(state == "HIVneg", incidenceHIV, 0)
}
#For progression in the Acute state
pProgressToHIVchronic <- function(state, cycle_in_state) {
ifelse(state == "HIVacute" & cycle_in_state >= n_cycles_acute, 1, 0)
}
pProgressToAIDS <- function(state){
p <- ifelse(state=="HIVchronic", pProgress_NoART,
ifelse(state=="HIVdiag_ART", pProgress_ART,
ifelse(state=="HIVdiag_NoART", pProgress_NoART, # change this in the params list
0)))
return(p)
}
#cycle2age <- function(cycle){
#  start_age + floor((cycle-1)/12)
#}
#age2cycle <- function(max_age){ #Should this be max_age?
#  (max_age - start_age) * 12 + 1
#}
#Going on treatment
# Going on treatment
fGo_on_ART <- function(state, pGo_on_ART) {
ifelse(state == "HIVdiag_NoART", pGo_on_ART, 0)
}
# Going off treatment
foff_ART <- function(state, poff_ART) {
ifelse(state == "HIVdiag_ART", poff_ART, 0)
}
## *Payoffs*
#The payoffs are the cost and utility functions*
# Function for Progression to AIDS
pProgressToAIDS <- function(state, pProgress_NoART, pProgress_ART) {
ifelse(state == "HIVchronic", pProgress_NoART,
ifelse(state == "HIVdiag_ART", pProgress_ART,
ifelse(state == "HIVdiag_NoART", pProgress_NoART, 0)))
}
# Probability of death
pDie <- function(state, cycle, hrDieHIV_NoART, smrDieHIV) {
r_background_mort <- rDie_background[cycle]
rDie <- ifelse(state == "HIVneg", r_background_mort,
ifelse(state == "HIVacute" | state == "HIVchronic" | state == "HIVdiag_NoART", r_background_mort * hrDieHIV_NoART,
ifelse(state == "HIVdiag_ART" | state == "AIDS", r_background_mort * smrDieHIV,
ifelse(state == "Dead", Inf, NA))))
rate2prob(rDie)
}
# Compute cost based on state and decision
cost <- function(decision, state, cycle, HIV_testing, get_conf_BT,
cProgramHIVST, cProgramHIVST_monthly, cHealthy, cNoART,
cART, cAIDS, cDie, cHIVST, cUsualcare, cBT) {
cost_decision <- ifelse(decision == "HIVST" & cycle == 1, cProgramHIVST, 0)
cost_decision2 <- ifelse(decision == "HIVST" & cycle > 1 & state %in% c("HIVneg", "HIVacute", "HIVchronic"), cProgramHIVST_monthly, 0)
cost_state <- ifelse(state == "HIVneg", cHealthy,
ifelse(state == "HIVacute" | state == "HIVchronic" | state == "HIVdiag_NoART", cNoART,
ifelse(state == "HIVdiag_ART", cART,
ifelse(state == "AIDS", cAIDS,
ifelse(state == "Dead", cDie, NA)))))
cost_event1 <- ifelse(decision == "HIVST" & HIV_testing == "Yes", cHIVST, 0)
cost_event2 <- ifelse(decision == "Usualcare" & HIV_testing == "Yes", cUsualcare, 0)
cost_event3 <- ifelse(get_conf_BT == "Yes", cBT, 0)
cost_state + cost_decision + cost_decision2 + cost_event1 + cost_event2 + cost_event3
}
# Compute utility based on state
utility <- function(state, uHealthy, uHIVacute, uHIVchronic, uHIVdiag_ART, uHIVdiag_NoART, uAIDS, uDie) {
ifelse(state == "HIVneg", uHealthy,
ifelse(state == "HIVacute", uHIVacute,
ifelse(state == "HIVchronic", uHIVchronic,
ifelse(state == "HIVdiag_ART", uHIVdiag_ART,
ifelse(state == "HIVdiag_NoART", uHIVdiag_NoART,
ifelse(state == "AIDS", uAIDS,
ifelse(state == "Dead", uDie, NA)))))))
}
# Compute life expectancy based on state
compute_le <- function(state) {
surv_state <- ifelse(state == "Dead", 0, 1)
surv_state / 12
}
#rm(list = ls())
#n_cycles <- 75
#library(data.table)
#source("sandbox/test_markov.R")
#source("sandbox/test_dataset_join_funs.R")
mytwig
results <- run_twig(mytwig, params, verbose = TRUE, parallel = FALSE)
mytwig <- twig()+
decisions(names = c("HIVST","Usualcare"))+
states(names=c("HIVneg","HIVacute","HIVchronic","HIVdiag_ART","HIVdiag_NoART","AIDS","Dead"),
init_probs=c(pHIVneg,pHIVacute,1-pHIVneg-pHIVacute,0,0,0,0),
max_cycles=c(1,n_cycles_acute,1,1,1,1,1))+ #inserted a 3 for the tunnel state
event(name="Alive",
options=c("Yes","none"),
probs=c("leftover","pDie"),
transitions=c("HIV_testing","Dead"))+
event(name="HIV_testing",
options=c("Yes","none"),
probs=c("pTest","leftover"),
transitions=c("HIVTest_result","New_infection"))+
event(name="HIVTest_result",
options=c("positive","none"),
probs=c("pTestpositive","leftover"),
transitions=c("get_conf_BT","New_infection"))+
event(name="get_conf_BT",
options=c("Yes","none"),
probs=c("fUseBT","leftover"),
transitions=c("Conf_BT_result","New_infection"))+
event(name="Conf_BT_result",
options=c("positive","none"),
probs=c("pTestpositive_BT","leftover"),
transitions=c("receiveART","New_infection"))+
event(name="receiveART",
options=c("Yes","none"),
probs=c("fHIV_diagART", "leftover"),
transitions=c("HIVdiag_ART", "HIVdiag_NoART"))+
event(name="New_infection",
options=c("Yes","none"),
probs=c("pNew_infection","leftover"),
transitions=c("HIVacute","Progress"))+ #"HIVchronic"
event(name="Progress",
options=c("toHIVchronic","toAIDS","none"),
probs=c("pProgressToHIVchronic","pProgressToAIDS","leftover"),
transitions=c("HIVchronic","AIDS","leave_curr_state"))+
event(name="leave_curr_state",
options=c("none","toOffART","toOnART"),
probs=c("leftover","foff_ART","fGo_on_ART"),
transitions=c("stay","HIVdiag_NoART","HIVdiag_ART")) +
payoffs(names = c("cost", "utility", "compute_le", "temp"),
discount_rates=c((1 + 0.015)^(1/12) - 1,(1 + 0.015)^(1/12) - 1,(1 + 0.015)^(1/12) - 1, 0)) # leftover0.015
results <- run_twig(mytwig, params, verbose = TRUE, parallel = FALSE)
pHIVchronic
1-pHIVneg-pHIVacute
n_cycles_acute <-3
mytwig <- twig()+
decisions(names = c("HIVST","Usualcare"))+
states(names=c("HIVneg","HIVacute","HIVchronic","HIVdiag_ART","HIVdiag_NoART","AIDS","Dead"),
init_probs=c(pHIVneg,pHIVacute,pHIVchronic,0,0,0,0),
max_cycles=c(1,n_cycles_acute,1,1,1,1,1))+ #inserted a 3 for the tunnel state
event(name="Alive",
options=c("Yes","none"),
probs=c("leftover","pDie"),
transitions=c("HIV_testing","Dead"))+
event(name="HIV_testing",
options=c("Yes","none"),
probs=c("pTest","leftover"),
transitions=c("HIVTest_result","New_infection"))+
event(name="HIVTest_result",
options=c("positive","none"),
probs=c("pTestpositive","leftover"),
transitions=c("get_conf_BT","New_infection"))+
event(name="get_conf_BT",
options=c("Yes","none"),
probs=c("fUseBT","leftover"),
transitions=c("Conf_BT_result","New_infection"))+
event(name="Conf_BT_result",
options=c("positive","none"),
probs=c("pTestpositive_BT","leftover"),
transitions=c("receiveART","New_infection"))+
event(name="receiveART",
options=c("Yes","none"),
probs=c("fHIV_diagART", "leftover"),
transitions=c("HIVdiag_ART", "HIVdiag_NoART"))+
event(name="New_infection",
options=c("Yes","none"),
probs=c("pNew_infection","leftover"),
transitions=c("HIVacute","Progress"))+ #"HIVchronic"
event(name="Progress",
options=c("toHIVchronic","toAIDS","none"),
probs=c("pProgressToHIVchronic","pProgressToAIDS","leftover"),
transitions=c("HIVchronic","AIDS","leave_curr_state"))+
event(name="leave_curr_state",
options=c("none","toOffART","toOnART"),
probs=c("leftover","foff_ART","fGo_on_ART"),
transitions=c("stay","HIVdiag_NoART","HIVdiag_ART")) +
payoffs(names = c("cost", "utility", "compute_le", "temp"),
discount_rates=c((1 + 0.015)^(1/12) - 1,(1 + 0.015)^(1/12) - 1,(1 + 0.015)^(1/12) - 1, 0)) # leftover0.015
results <- run_twig(mytwig, params, verbose = TRUE, parallel = FALSE)
n_cycles
traceback()
results <- run_twig(mytwig, params, n_cycles = n_cycles, verbose = TRUE, parallel = FALSE)
traceback()
get_compl_event_ids <- function(events_df, hash_string){
events_df$id <- seq_len(nrow(events_df))
# return a list of event_ids and their complements
# hash_string <- "COMPLEMENT" #"\"#\""
hash_id <- events_df$id[events_df$probs == hash_string]
compl_ids <- list()
unique_events <- unique(events_df$event)
for (i in 1:length(unique_events)){
compl_ids[[unique_events[i]]] <- events_df$id[events_df$event == events_df$event[hash_id[i]] &
events_df$id != events_df$id[hash_id[i]]]
}
return(compl_ids)
}
results <- run_twig(mytwig, params, n_cycles = n_cycles, verbose = TRUE, parallel = FALSE)
traceback()
run_markov_simulation <- function(sim, twig_list, verbose = FALSE, offset_trace_cycle = 1){
# Assuming twig_read_only_env is a list or environment containing the necessary variables
with(twig_list, {
# sim_offset <- compute_sim_offset(sim, prob_reward_funs, sim_offset0)
# 3. F(sim) = same as IDX. Harmonize probs sim -------------------------------------------------
# parallellize
# add an option to store and output intermediate matrices with a warning about matrix sizes
eval_funs <- evaluate_functions(sim, fun_core_df, fun_sim_args, prob_reward_funs, params, arg_value_sizes, fun_args)
# print(eval_funs)
F <- evaluate_fun_sim(F0, IDX, prob_funs, eval_funs)
# source("R/steps/step_3_harmonize_probs.R")
# # 4. E: Create a single event array  -------------------------------------------------
# # if any is cycle dependent, dims = j=D, S, +/-C, j=event_id
# # for complement probs # = 1 - sum other probs
# E[D,S,C,E(s),j=event_id]. so similar to the F array,
# but with the event_id instead of the prob_funs, which
# involves computing the complement of the probs.
# adjustments of the event array for each sim
#dim(F) <- c(prod(core_arg_value_sizes), n_prob_funs)
E <- get_E(E0, F, non_compl_id, event_prob_link, hash_id, compl_id)
# source("R/steps/step_4_event_array.R")
# print(E)
# # 5. A[,,,k]: Create a single path array ---------------------------------------------
# # product of all E[,,,j] that are in on each path k=path_id
A <- get_A(A0_idx, E, A_idx, paths, n_paths)
# source("R/steps/step_5_path_array.R")
# print(A)
# # 6. P: Create transition probs ----------------------------------------
# # sum of all A[,,,k] that lead to the same destination Y
P_array <- calculate_transition_probs(P0_mat, A, dest_paths, unique_non_current_dest, dim_P, dimnames_P, is_cycle_dep, unique_dest_names, p_stay)
# source("R/steps/step_6_transition_probs.R")
# print(P_array)
# # 7. P0: Expand initial prob ----------------------------------------
# # can be numeric, global variable or a function of D, sim.
# source("R/steps/step_7_expand_initial_prob.R")
# print(p0_array)
# # 8. T: Create trace ---------------------------------------------------------
# # iteratively multiply state distribution by P
# source("R/steps/step_8_create_trace.R")
# print(T_array)
T_array <- create_trace_array(arg_value_sizes, arg_values, p0_array[,,sim],
P_array, sim, is_cycle_dep, n_decisions, n_cycles)
# # 9. R0: create a single array for all event-dep rewards by path k --------------
# # rewards are by evnets, but have to be made dependent on path k
# # 10. multiply event-dep rewards and event arrays---------------------------
# # for each reward doing a redim so it is [DSC * K] and then doing an element
# # wise multiplication, and then colSum, and then redimming to D, S, +/-C.
# # 11. R: create a single array of all rewards ------------------------------
# # iteratre through each reward, and fill in a single array D,S,C,r=reward_id
# source("R/steps/step_9_reward_event_dep_array.R")
# print(R_array)
# 10. RC: multiply rewards and trace R * T * discount -------------------------------------------
# 11. RS: create summary payoffs ----------------------------------------------
R_array <- calculate_rewards(sim, R0_array, event_indep_rewards, eval_funs, R_non_event_dep_idx,
IDX_path_dep, event_dep_rewards, A, reward_funs, dimnames_R0, size_core_non_event_args)
R_array_cycle <- return_R_array_cycle(R_array, reward_funs, T_array, array_discount, n_cycles, offset_trace_cycle = offset_trace_cycle)
R_sim <- apply(R_array_cycle, c(3,4), sum)
if (verbose){
# browser()
evaluated_funs <- list()
for (fun in twig_funs){
if (nrow(fun_core_df[[fun]] > 0)){
evaluated_funs[[fun]] <- cbind(fun_core_df[[fun]], eval_funs[fun])
} else {
evaluated_funs[[fun]] <- eval_funs[fun]
}
}
sim_results <- list(sim = sim,
Rewards_sim = R_sim,
Rewards_array = R_array,
Rewards_array_cycle = R_array_cycle,
Trace_array = T_array,
TransitionProb_array = P_array,
Paths = A,
Event_options = E,
Function_Values = F,
evaluated_funs = evaluated_funs)
return(sim_results)
} else {
return(R_sim)
}
gc()
}) # end with statement
} # end function
results <- run_twig(mytwig, params, n_cycles = n_cycles, verbose = TRUE, parallel = FALSE)
traceback()
results$Rewards_sim
run_r_in_folder <- function(functions_folder){
# List all .R files in the folder
function_files <- list.files(functions_folder, pattern = "\\.R$", full.names = TRUE)
# Source each file
sapply(function_files, source)
print(function_files)
}
run_r_in_folder("R/functions")
options(warn=2)
results <- run_twig(mytwig, params, n_cycles = n_cycles, verbose = TRUE, parallel = FALSE)
run_markov_simulation <- function(sim, twig_list, verbose = FALSE, offset_trace_cycle = 1){
# Assuming twig_read_only_env is a list or environment containing the necessary variables
with(twig_list, {
# sim_offset <- compute_sim_offset(sim, prob_reward_funs, sim_offset0)
# 3. F(sim) = same as IDX. Harmonize probs sim -------------------------------------------------
# parallellize
# add an option to store and output intermediate matrices with a warning about matrix sizes
eval_funs <- evaluate_functions(sim, fun_core_df, fun_sim_args, prob_reward_funs, params, arg_value_sizes, fun_args)
# print(eval_funs)
F <- evaluate_fun_sim(F0, IDX, prob_funs, eval_funs)
# source("R/steps/step_3_harmonize_probs.R")
# # 4. E: Create a single event array  -------------------------------------------------
# # if any is cycle dependent, dims = j=D, S, +/-C, j=event_id
# # for complement probs # = 1 - sum other probs
# E[D,S,C,E(s),j=event_id]. so similar to the F array,
# but with the event_id instead of the prob_funs, which
# involves computing the complement of the probs.
# adjustments of the event array for each sim
#dim(F) <- c(prod(core_arg_value_sizes), n_prob_funs)
E <- get_E(E0, F, non_compl_id, event_prob_link, hash_id, compl_id)
# source("R/steps/step_4_event_array.R")
# print(E)
# # 5. A[,,,k]: Create a single path array ---------------------------------------------
# # product of all E[,,,j] that are in on each path k=path_id
A <- get_A(A0_idx, E, A_idx, paths, n_paths)
# source("R/steps/step_5_path_array.R")
# print(A)
# # 6. P: Create transition probs ----------------------------------------
# # sum of all A[,,,k] that lead to the same destination Y
P_array <- calculate_transition_probs(P0_mat, A, dest_paths, unique_non_current_dest, dim_P, dimnames_P, is_cycle_dep, unique_dest_names, p_stay)
# source("R/steps/step_6_transition_probs.R")
# print(P_array)
# # 7. P0: Expand initial prob ----------------------------------------
# # can be numeric, global variable or a function of D, sim.
# source("R/steps/step_7_expand_initial_prob.R")
# print(p0_array)
# # 8. T: Create trace ---------------------------------------------------------
# # iteratively multiply state distribution by P
# source("R/steps/step_8_create_trace.R")
# print(T_array)
T_array <- create_trace_array(arg_value_sizes, arg_values, p0_array[,,sim],
P_array, sim, is_cycle_dep, n_decisions, n_cycles)
# # 9. R0: create a single array for all event-dep rewards by path k --------------
# # rewards are by evnets, but have to be made dependent on path k
# # 10. multiply event-dep rewards and event arrays---------------------------
# # for each reward doing a redim so it is [DSC * K] and then doing an element
# # wise multiplication, and then colSum, and then redimming to D, S, +/-C.
# # 11. R: create a single array of all rewards ------------------------------
# # iteratre through each reward, and fill in a single array D,S,C,r=reward_id
# source("R/steps/step_9_reward_event_dep_array.R")
# print(R_array)
# 10. RC: multiply rewards and trace R * T * discount -------------------------------------------
# 11. RS: create summary payoffs ----------------------------------------------
R_array <- calculate_rewards(sim, R0_array, event_indep_rewards, eval_funs, R_non_event_dep_idx,
IDX_path_dep, event_dep_rewards, A, reward_funs, dimnames_R0, size_core_non_event_args)
R_array_cycle <- return_R_array_cycle(R_array, reward_funs, T_array, array_discount, n_cycles, offset_trace_cycle = offset_trace_cycle)
R_sim <- apply(R_array_cycle, c(3,4), sum)
if (verbose){
# browser()
evaluated_funs <- list()
for (fun in twig_funs){
if (nrow(fun_core_df[[fun]]) > 0){
evaluated_funs[[fun]] <- cbind(fun_core_df[[fun]], eval_funs[fun])
} else {
evaluated_funs[[fun]] <- eval_funs[fun]
}
}
sim_results <- list(sim = sim,
Rewards_sim = R_sim,
Rewards_array = R_array,
Rewards_array_cycle = R_array_cycle,
Trace_array = T_array,
TransitionProb_array = P_array,
Paths = A,
Event_options = E,
Function_Values = F,
evaluated_funs = evaluated_funs)
return(sim_results)
} else {
return(R_sim)
}
gc()
}) # end with statement
} # end function
results <- run_twig(mytwig, params, n_cycles = n_cycles, verbose = TRUE, parallel = FALSE)
results$Rewards_sim
results <- run_twig(mytwig, params = params_psa, n_cycles = n_cycles, verbose = F, parallel = TRUE)
