nmb_proportions_list
# Apply the NMB formula to each slice of the 3D array
nmb_results <- apply(rewards_sim, 3, calculate_nmb, wtp = wtp)
# Transpose the results to have simulations as rows and decisions as columns
nmb_df <- as.data.frame(t(nmb_results))
# Identify the column with the highest value for each row
max_nmb <- apply(nmb_df, 1, which.max)
max_nmb <- matrix(0, nrow = nrow(nmb_df), ncol = ncol(nmb_df))
max_nmb[cbind(1:nrow(nmb_df), max_nmb)] <- 1
colnames(max_nmb) <- colnames(nmb_df)
highest_col <- max.col(nmb_df, ties.method = "first")
# Store the proportions in the list
nmb_proportions_list[[as.character(wtp)]] <- colMeans(max_nmb)
nmb_proportions_list
# Convert the list to a data frame
nmb_proportions_df <- rbind(nmb_proportions_list)
nmb_proportions_df
# Convert the list to a data frame
nmb_proportions_df <- rbind(nmb_proportions_list)
nmb_proportions_df
nmb_proportions_list
rewards_sim
ncol(rewards_sim))
ncol(rewards_sim)
# Initialize a list to store the results
nmb_proportions_mat <- matrix(NA, nrow = length(wtp_range), ncol = ncol(rewards_sim))
# Store the proportions in the list
nmb_proportions_mat[i,] <- colMeans(max_nmb)
i <- 0
i <- i + 1
# Store the proportions in the list
nmb_proportions_mat[i,] <- colMeans(max_nmb)
nmb_proportions_mat
# Initialize a list to store the results
nmb_proportions_mat <- matrix(NA, nrow = length(wtp_range), ncol = nrow(rewards_sim))
nmb_proportions_mat
# Store the proportions in the list
nmb_proportions_mat[i,] <- colMeans(max_nmb)
nmb_proportions_mat
# Initialize a list to store the results
nmb_proportions_mat <- matrix(NA, nrow = length(wtp_range), ncol = nrow(rewards_sim),
colnames = dimnames(rewards_sim)[[1]])
# Initialize a list to store the results
nmb_proportions_mat <- matrix(NA, nrow = length(wtp_range), ncol = nrow(rewards_sim),
dimnames = c(NULL, dimnames(rewards_sim)[[1]]))
# Initialize a list to store the results
nmb_proportions_mat <- matrix(NA, nrow = length(wtp_range), ncol = nrow(rewards_sim),
dimnames = list(NULL, dimnames(rewards_sim)[[1]]))
nmb_proportions_mat
# Convert the list to a data frame
# Add the wtp_range as a column
nmb_proportions_df <- cbind(wtp = wtp_range, nmb_proportions_df)
# Convert the list to a data frame
# Add the wtp_range as a column
nmb_proportions_df <- cbind(wtp = wtp_range, nmb_proportions_mat)
nmb_proportions_df
# Loop over each value in wtp_range
for (wtp in wtp_range) {
i <- i + 1
# Apply the NMB formula to each slice of the 3D array
nmb_results <- apply(rewards_sim, 3, calculate_nmb, wtp = wtp)
# Transpose the results to have simulations as rows and decisions as columns
nmb_df <- as.data.frame(t(nmb_results))
# Add column names for decisions
# colnames(nmb_df) <- dimnames(rewards_sim)[[1]]
# Identify the column with the highest value for each row
max_nmb <- apply(nmb_df, 1, which.max)
max_nmb <- matrix(0, nrow = nrow(nmb_df), ncol = ncol(nmb_df))
max_nmb[cbind(1:nrow(nmb_df), max_nmb)] <- 1
colnames(max_nmb) <- colnames(nmb_df)
highest_col <- max.col(nmb_df, ties.method = "first")
# Store the proportions in the list
nmb_proportions_mat[i,] <- colMeans(max_nmb)
}
# Reshape nmb_proportions_df to long format using reshape2
nmb_proportions_long <- reshape2::melt(as.data.frame(nmb_proportions_df), id.vars = "wtp", variable.name = "decision", value.name = "prob_cost_effective")
run_r_in_folder("R/functions")
plot_ceac(results$Rewards_sim, wtp_range = seq(0, 100000, by = 1000))
mytwig <- twig() +
decisions(names = c(A,B)) + # decision alternatives
states(names=c(Alive,Dead), # Markov state names
init_probs=c(1,0)) + # The cohort starts healthy
event(name=death_event, # A death event can occur with
options=c(yes,none),  # 2 options "yes" and "none",
probs=c(pDie,leftover), # that can occur with probabilities pDie and 1-pDie,
transitions=c(Dead,stay)) + # can lead to death state otherwise stay in their current state
payoffs(names = c(cost, utility))  # we measure the cost and utility of the cohort
pDie <- function(state, decision, rrMortA){
rDie <- 0.2 * (state=="Alive") * rrMortA ^ (decision=="A") # rate of probability increases at 0.01 per cycle (year)
rate2prob(rDie) # convert the rate into probability
}
# cost is a function of the decision
cost <- function(decision, cA, cB){
cA * (decision=="A") +
cB * (decision=="B")
}
# utility is uAlive if alive, otherwise 0
utility <- function(state, uAlive){
uAlive * (state=="Alive")
}
n_sims <- 10000
psa_params <- data.frame(
rrMortA = rnorm(n_sims, 0.95, 0.001),
cA = rlnorm(n_sims, 5, 1),
cB = rlnorm(n_sims, 4, 1),
uAlive = rbeta(n_sims, 0.8, 0.2)
)
head(psa_params)
results <- run_twig(twig_obj = mytwig, params = psa_params, n_cycles = 50, parallel = TRUE)
results$Rewards_summary
calculate_icers(results$Rewards_summary)
plot_ceac(results$Rewards_sim, wtp_range = seq(0, 100000, by = 1000))
plot_ceac(results$Rewards_sim, wtp_range = seq(0, 100000, by = 1000))
run_r_in_folder("R/functions")
plot_ceac(results$Rewards_sim, wtp_range = seq(0, 100000, by = 1000))
nmb_proportions_mat
wtp
max_nmb
nmb_df
# Identify the column with the highest value for each row
max_nmb <- apply(nmb_df, 1, which.max)
max_nmb
# Identify the column with the highest value for each row
max_nmb <- apply(nmb_df, 1, which.max)
nmb_mat <- matrix(0, nrow = nrow(nmb_df), ncol = ncol(nmb_df))
nmb_mat[cbind(1:nrow(nmb_df), max_nmb)] <- 1
nmb_mat
colMeans(nmb_mat)
run_r_in_folder("R/functions")
plot_ceac(results$Rewards_sim, wtp_range = seq(0, 100000, by = 1000))
run_r_in_folder("R/functions")
# Markov model example =================
rm(list = ls())
options(width = 200)
run_r_in_folder <- function(functions_folder){
# List all .R files in the folder
function_files <- list.files(functions_folder, pattern = "\\.R$", full.names = TRUE)
# Source each file
sapply(function_files, source)
print(function_files)
}
run_r_in_folder("R/functions")
n_sims <- 100
n_cycles <- 10
source("examples/test_markov.R")
#source("R/evaluate_prob_reward_functions.R")
twig_obj
results <- run_twig(twig_obj, params, n_cycles, verbose = F, parallel = TRUE,  offset_trace_cycle = 0)
results$Rewards_sim
#                    cost  utility
# StandardOfCare 12938.81 4.756735
# StrategyA      22979.69 4.911393
# StrategyB      23475.64 4.764146
# StrategyAB     33457.56 4.922687
calculate_icers(results$Rewards_summary)
run_r_in_folder("R/functions")
plot_ceac(results$Rewards_sim, wtp_range = seq(0, 100000, by = 1000))
n_sims <- 10000
n_cycles <- 75
source("examples/test_markov.R")
#source("R/evaluate_prob_reward_functions.R")
twig_obj
results <- run_twig(twig_obj, params, n_cycles, verbose = F, parallel = TRUE,  offset_trace_cycle = 0)
results$Rewards_sim
#                    cost  utility
# StandardOfCare 12938.81 4.756735
# StrategyA      22979.69 4.911393
# StrategyB      23475.64 4.764146
# StrategyAB     33457.56 4.922687
calculate_icers(results$Rewards_summary)
run_r_in_folder("R/functions")
plot_ceac(results$Rewards_sim, wtp_range = seq(0, 100000, by = 1000))
params
n_sims <- 5000
n_cycles <- 75
source("examples/test_markov.R")
#source("R/evaluate_prob_reward_functions.R")
twig_obj
results <- run_twig(twig_obj, params, n_cycles, verbose = F, parallel = TRUE,  offset_trace_cycle = 0)
results$Rewards_sim
#                    cost  utility
# StandardOfCare 12938.81 4.756735
# StrategyA      22979.69 4.911393
# StrategyB      23475.64 4.764146
# StrategyAB     33457.56 4.922687
calculate_icers(results$Rewards_summary)
run_r_in_folder("R/functions")
plot_ceac(results$Rewards_sim, wtp_range = seq(0, 100000, by = 1000))
# Markov model example =================
rm(list = ls())
options(width = 200)
run_r_in_folder <- function(functions_folder){
# List all .R files in the folder
function_files <- list.files(functions_folder, pattern = "\\.R$", full.names = TRUE)
# Source each file
sapply(function_files, source)
print(function_files)
}
run_r_in_folder("R/functions")
run_r_in_folder("R/functions")
rm(list = ls())
options(width = 200)
run_r_in_folder <- function(functions_folder){
# List all .R files in the folder
function_files <- list.files(functions_folder, pattern = "\\.R$", full.names = TRUE)
# Source each file
sapply(function_files, source)
print(function_files)
}
run_r_in_folder("R/functions")
function_files
run_r_in_folder("R/functions")
source("~/github/twig/R/functions/create_twig_obj.R", echo=TRUE)
# rm(list = ls())
#library(twig)
n_cycles <- 75
twig_obj <- twig() +
decisions(names = c(StandardOfCare, StrategyA, StrategyB, StrategyAB)) + # define decisions
states(names = c(H, S1, S2, D), # Markov state names
init_probs = c(1,0,0,0), # everyone starts at H
max_cycles = c(1,n_cycles, 1, 1)) + # the cohort can stay in S1 for n_cycles
event(name = death_event,  # first event is death
options = c(yes,none), # which 2 options
probs = c(pDie, leftover), # probability function name and its complement
transitions = c(D, second_event)) + # if death occurs go to D, otherwise, go to the next event (second_event)
event(name = second_event, # the second event
options = c(recover, getsick, progress, none), # has 4 options
probs = c(pRecover, pGetSick, pProgress, leftover), # and 3 named probabilities and a complement
transitions = c(H, S1, S2, stay)) + # resulting in transitions to H, S1, S2 or else staying in the original state
payoffs(names = c(cost, utility), # payoff names
discount_rates = c(0.03, 0.03)) # payoff discount rates
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# rm(list = ls())
#library(twig)
n_cycles <- 75
twig_obj <- twig() +
decisions(names = c(StandardOfCare, StrategyA, StrategyB, StrategyAB)) + # define decisions
states(names = c(H, S1, S2, D), # Markov state names
init_probs = c(1,0,0,0), # everyone starts at H
max_cycles = c(1,n_cycles, 1, 1)) + # the cohort can stay in S1 for n_cycles
event(name = death_event,  # first event is death
options = c(yes,none), # which 2 options
probs = c(pDie, leftover), # probability function name and its complement
transitions = c(D, second_event)) + # if death occurs go to D, otherwise, go to the next event (second_event)
event(name = second_event, # the second event
options = c(recover, getsick, progress, none), # has 4 options
probs = c(pRecover, pGetSick, pProgress, leftover), # and 3 named probabilities and a complement
transitions = c(H, S1, S2, stay)) + # resulting in transitions to H, S1, S2 or else staying in the original state
payoffs(names = c(cost, utility), # payoff names
discount_rates = c(0.03, 0.03)) # payoff discount rates
# n_sims <- 5000
# Create the data.table with n_sim rows of random samples
params <- data.frame(
r_HS1         = rbeta(n_sims, 2, 10),             # Transition rate with beta distribution
r_S1H         = rbeta(n_sims, 5, 5),              # Another transition rate with a different shape
hr_S1         = rlnorm(n_sims, log(3), 0.2),      # Hazard ratio, log-normal to allow skewness
hr_S2         = rlnorm(n_sims, log(10), 0.2),     # Higher hazard ratio, same distribution
hr_S1S2_trtB  = rbeta(n_sims, 6, 4),              # Hazard ratio under treatment with beta distribution
r_S1S2_scale  = rgamma(n_sims, shape = 2, rate = 25), # Scale parameter, gamma distribution
r_S1S2_shape  = rgamma(n_sims, shape = 3, rate = 3),  # Shape parameter, gamma distribution
c_H           = rnorm(n_sims, mean = 2000, sd = 50),   # Annual cost, slight variation for simulation
c_S1          = rnorm(n_sims, mean = 4000, sd = 100),  # Higher annual cost, slightly varied
c_S2          = rnorm(n_sims, mean = 15000, sd = 500), # Large cost with moderate variation
c_D           = 0,                                        # Constant, no variation
c_trtA        = rnorm(n_sims, mean = 12000, sd = 200), # Cost of treatment A with small variation
c_trtB        = rnorm(n_sims, mean = 13000, sd = 200), # Cost of treatment B
u_H           = rbeta(n_sims, 10, 1),                  # Utility close to 1 for Healthy
u_S1          = rbeta(n_sims, 7.5, 2.5),               # Utility less than Healthy, beta distribution
u_S2          = rbeta(n_sims, 5, 5),                   # Utility for Sicker
u_D           = 0,                                        # Utility for Dead is constant
u_trtA        = rbeta(n_sims, 9.5, 1),                 # Utility with treatment A, close to Healthy
du_HS1        = rnorm(n_sims, mean = 0.01, sd = 0.005), # Disutility with slight variation
ic_HS1        = rnorm(n_sims, mean = 1000, sd = 100),   # Cost increase with transition
ic_D          = rnorm(n_sims, mean = 2000, sd = 100),    # Cost increase when dying
p0_H          = rbeta(n_sims, 1, 9)                   # Initial probability of being Healthy
)
n_sims <- 5000
# Create the data.table with n_sim rows of random samples
params <- data.frame(
r_HS1         = rbeta(n_sims, 2, 10),             # Transition rate with beta distribution
r_S1H         = rbeta(n_sims, 5, 5),              # Another transition rate with a different shape
hr_S1         = rlnorm(n_sims, log(3), 0.2),      # Hazard ratio, log-normal to allow skewness
hr_S2         = rlnorm(n_sims, log(10), 0.2),     # Higher hazard ratio, same distribution
hr_S1S2_trtB  = rbeta(n_sims, 6, 4),              # Hazard ratio under treatment with beta distribution
r_S1S2_scale  = rgamma(n_sims, shape = 2, rate = 25), # Scale parameter, gamma distribution
r_S1S2_shape  = rgamma(n_sims, shape = 3, rate = 3),  # Shape parameter, gamma distribution
c_H           = rnorm(n_sims, mean = 2000, sd = 50),   # Annual cost, slight variation for simulation
c_S1          = rnorm(n_sims, mean = 4000, sd = 100),  # Higher annual cost, slightly varied
c_S2          = rnorm(n_sims, mean = 15000, sd = 500), # Large cost with moderate variation
c_D           = 0,                                        # Constant, no variation
c_trtA        = rnorm(n_sims, mean = 12000, sd = 200), # Cost of treatment A with small variation
c_trtB        = rnorm(n_sims, mean = 13000, sd = 200), # Cost of treatment B
u_H           = rbeta(n_sims, 10, 1),                  # Utility close to 1 for Healthy
u_S1          = rbeta(n_sims, 7.5, 2.5),               # Utility less than Healthy, beta distribution
u_S2          = rbeta(n_sims, 5, 5),                   # Utility for Sicker
u_D           = 0,                                        # Utility for Dead is constant
u_trtA        = rbeta(n_sims, 9.5, 1),                 # Utility with treatment A, close to Healthy
du_HS1        = rnorm(n_sims, mean = 0.01, sd = 0.005), # Disutility with slight variation
ic_HS1        = rnorm(n_sims, mean = 1000, sd = 100),   # Cost increase with transition
ic_D          = rnorm(n_sims, mean = 2000, sd = 100),    # Cost increase when dying
p0_H          = rbeta(n_sims, 1, 9)                   # Initial probability of being Healthy
)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# rm(list = ls())
#library(twig)
n_cycles <- 75
twig_obj <- twig() +
decisions(names = c(StandardOfCare, StrategyA, StrategyB, StrategyAB)) + # define decisions
states(names = c(H, S1, S2, D), # Markov state names
init_probs = c(1,0,0,0), # everyone starts at H
max_cycles = c(1,n_cycles, 1, 1)) + # the cohort can stay in S1 for n_cycles
event(name = death_event,  # first event is death
options = c(yes,none), # which 2 options
probs = c(pDie, leftover), # probability function name and its complement
transitions = c(D, second_event)) + # if death occurs go to D, otherwise, go to the next event (second_event)
event(name = second_event, # the second event
options = c(recover, getsick, progress, none), # has 4 options
probs = c(pRecover, pGetSick, pProgress, leftover), # and 3 named probabilities and a complement
transitions = c(H, S1, S2, stay)) + # resulting in transitions to H, S1, S2 or else staying in the original state
payoffs(names = c(cost, utility), # payoff names
discount_rates = c(0.03, 0.03)) # payoff discount rates
n_sims <- 5000
# Create the data.table with n_sim rows of random samples
params <- data.frame(
r_HS1         = rbeta(n_sims, 2, 10),             # Transition rate with beta distribution
r_S1H         = rbeta(n_sims, 5, 5),              # Another transition rate with a different shape
hr_S1         = rlnorm(n_sims, log(3), 0.2),      # Hazard ratio, log-normal to allow skewness
hr_S2         = rlnorm(n_sims, log(10), 0.2),     # Higher hazard ratio, same distribution
hr_S1S2_trtB  = rbeta(n_sims, 6, 4),              # Hazard ratio under treatment with beta distribution
r_S1S2_scale  = rgamma(n_sims, shape = 2, rate = 25), # Scale parameter, gamma distribution
r_S1S2_shape  = rgamma(n_sims, shape = 3, rate = 3),  # Shape parameter, gamma distribution
c_H           = rnorm(n_sims, mean = 2000, sd = 50),   # Annual cost, slight variation for simulation
c_S1          = rnorm(n_sims, mean = 4000, sd = 100),  # Higher annual cost, slightly varied
c_S2          = rnorm(n_sims, mean = 15000, sd = 500), # Large cost with moderate variation
c_D           = 0,                                        # Constant, no variation
c_trtA        = rnorm(n_sims, mean = 12000, sd = 200), # Cost of treatment A with small variation
c_trtB        = rnorm(n_sims, mean = 13000, sd = 200), # Cost of treatment B
u_H           = rbeta(n_sims, 10, 1),                  # Utility close to 1 for Healthy
u_S1          = rbeta(n_sims, 7.5, 2.5),               # Utility less than Healthy, beta distribution
u_S2          = rbeta(n_sims, 5, 5),                   # Utility for Sicker
u_D           = 0,                                        # Utility for Dead is constant
u_trtA        = rbeta(n_sims, 9.5, 1),                 # Utility with treatment A, close to Healthy
du_HS1        = rnorm(n_sims, mean = 0.01, sd = 0.005), # Disutility with slight variation
ic_HS1        = rnorm(n_sims, mean = 1000, sd = 100),   # Cost increase with transition
ic_D          = rnorm(n_sims, mean = 2000, sd = 100),    # Cost increase when dying
p0_H          = rbeta(n_sims, 1, 9)                   # Initial probability of being Healthy
)
pRecover <- function(state, r_S1H){
rRecover <- r_S1H * (state=="S1")
rate2prob(rRecover)
}
pGetSick <- function(state, r_HS1){
rGetSick <- r_HS1 * (state=="H")
rate2prob(rGetSick)
}
pProgress <- function(state, decision, cycle_in_state,
hr_S1S2_trtB, r_S1S2_scale, r_S1S2_shape){
hr_S1S2 <- hr_S1S2_trtB ^ (decision %in% c("StrategyB", "StrategyAB")) # hazard rate of progression for B or 1 otherwise
r_S1S2_tunnels <- ((cycle_in_state*r_S1S2_scale)^r_S1S2_shape -
((cycle_in_state - 1)*r_S1S2_scale)^r_S1S2_shape) # hazard rate based on cycle_in_state (tunnel) which follows a weibull distribution
# only those who are at S1 can progress
rProgress <- r_S1S2_tunnels * (state=="S1") * hr_S1S2
rate2prob(rProgress)
}
n_age_init <- 24 # starting age
n_age_max  <- 100 # maximum age of simulation
## Age-dependent mortality rates
lt_usa_2015 <- read.csv("../inst/extdata/LifeTable_USA_Mx_2015.csv")
# choose mortality rates from the
v_r_mort_by_age <- as.matrix(lt_usa_2015$Total[lt_usa_2015$Age >= n_age_init & lt_usa_2015$Age < n_age_max])
# death depends on the state and age.
pDie <- function(state, cycle,
hr_S1, hr_S2){
r_HD <- v_r_mort_by_age[cycle] # get age-specific mortality
rDie <- r_HD * (state=="H") +  # baseline mortality if healthy
r_HD*hr_S1 * (state=="S1") +  # multiplied by a hazard rate if S1 or
r_HD*hr_S2 * (state=="S2") # S2
# else 0
rate2prob(rDie)
}
cost <- function(state, decision, second_event, death_event,
ic_HS1, ic_D, c_trtA, c_trtB,
c_H, c_S1, c_S2, c_D){
# cost of decision is only applied if the state is either S1 or S2
trans_cost_getting_sick <- ic_HS1 * (second_event=="getsick") # increase in cost when transitioning from Healthy to Sick
trans_cost_dying <- ic_D * (death_event=="yes") # increase in cost when dying
c_decision <- (state %in% c("S1","S2")) * (
c_trtA * (decision=="StrategyA") +
c_trtB * (decision=="StrategyB") +
(c_trtA + c_trtB) * (decision=="StrategyAB")
)
# cost of the state is a function of the state
c_state <- c_H * (state=="H") +
c_S1 * (state=="S1") +
c_S2 * (state=="S2") +
c_D * (state=="D")
# combine both
return(c_decision + c_state + trans_cost_getting_sick + trans_cost_dying)
}
results <- run_twig(twig_obj = mytwig, params = psa_params, n_cycles = n_cycles, parallel = TRUE)
n_cycles <- 75
mytwig <- twig() +
decisions(names = c(StandardOfCare, StrategyA, StrategyB, StrategyAB)) + # define decisions
states(names = c(H, S1, S2, D), # Markov state names
init_probs = c(1,0,0,0), # everyone starts at H
max_cycles = c(1,n_cycles, 1, 1)) + # the cohort can stay in S1 for n_cycles
event(name = death_event,  # first event is death
options = c(yes,none), # which 2 options
probs = c(pDie, leftover), # probability function name and its complement
transitions = c(D, second_event)) + # if death occurs go to D, otherwise, go to the next event (second_event)
event(name = second_event, # the second event
options = c(recover, getsick, progress, none), # has 4 options
probs = c(pRecover, pGetSick, pProgress, leftover), # and 3 named probabilities and a complement
transitions = c(H, S1, S2, stay)) + # resulting in transitions to H, S1, S2 or else staying in the original state
payoffs(names = c(cost, utility), # payoff names
discount_rates = c(0.03, 0.03)) # payoff discount rates
results <- run_twig(twig_obj = mytwig, params = psa_params, n_cycles = n_cycles, parallel = TRUE)
n_sims <- 5000
# Create the data.table with n_sim rows of random samples
params <- data.frame(
r_HS1         = rbeta(n_sims, 2, 10),             # Transition rate with beta distribution
r_S1H         = rbeta(n_sims, 5, 5),              # Another transition rate with a different shape
hr_S1         = rlnorm(n_sims, log(3), 0.2),      # Hazard ratio, log-normal to allow skewness
hr_S2         = rlnorm(n_sims, log(10), 0.2),     # Higher hazard ratio, same distribution
hr_S1S2_trtB  = rbeta(n_sims, 6, 4),              # Hazard ratio under treatment with beta distribution
r_S1S2_scale  = rgamma(n_sims, shape = 2, rate = 25), # Scale parameter, gamma distribution
r_S1S2_shape  = rgamma(n_sims, shape = 3, rate = 3),  # Shape parameter, gamma distribution
c_H           = rnorm(n_sims, mean = 2000, sd = 50),   # Annual cost, slight variation for simulation
c_S1          = rnorm(n_sims, mean = 4000, sd = 100),  # Higher annual cost, slightly varied
c_S2          = rnorm(n_sims, mean = 15000, sd = 500), # Large cost with moderate variation
c_D           = 0,                                        # Constant, no variation
c_trtA        = rnorm(n_sims, mean = 12000, sd = 200), # Cost of treatment A with small variation
c_trtB        = rnorm(n_sims, mean = 13000, sd = 200), # Cost of treatment B
u_H           = rbeta(n_sims, 10, 1),                  # Utility close to 1 for Healthy
u_S1          = rbeta(n_sims, 7.5, 2.5),               # Utility less than Healthy, beta distribution
u_S2          = rbeta(n_sims, 5, 5),                   # Utility for Sicker
u_D           = 0,                                        # Utility for Dead is constant
u_trtA        = rbeta(n_sims, 9.5, 1),                 # Utility with treatment A, close to Healthy
du_HS1        = rnorm(n_sims, mean = 0.01, sd = 0.005), # Disutility with slight variation
ic_HS1        = rnorm(n_sims, mean = 1000, sd = 100),   # Cost increase with transition
ic_D          = rnorm(n_sims, mean = 2000, sd = 100),    # Cost increase when dying
p0_H          = rbeta(n_sims, 1, 9)                   # Initial probability of being Healthy
)
results <- run_twig(twig_obj = mytwig, params = params, n_cycles = n_cycles, parallel = TRUE)
results$Rewards_summary
calculate_icers(results$Rewards_summary)
plot_ceac(results$Rewards_sim, wtp_range = seq(0, 100000, by = 1000))
results$Rewards_sim
utility <- function(state, decision, second_event,
du_HS1, u_H, u_trtA, u_S1, u_S2, u_D){
trans_util_getting_sick <- -du_HS1 * (second_event=="getsick") # apply a utility discount for those who get sick.
# calcualte state utilities. note that S1 will have utility u_trtA if the decision involves A, and another utility if the decision does not involve A.
u_state <- u_H * (state=="H") +
u_trtA * (state=="S1" & decision %in% c("StrategyA", "StrategyAB")) +
u_S1 * (state=="S1" & decision %out% c("StrategyA", "StrategyAB")) +
u_S2 * (state=="S2") +
u_D * (state=="D")
# combine the two utilities.
return(u_state + trans_util_getting_sick)
}
n_sims <- 1000
# Create the data.table with n_sim rows of random samples
params <- data.frame(
r_HS1         = rbeta(n_sims, 2, 10),             # Transition rate with beta distribution
r_S1H         = rbeta(n_sims, 5, 5),              # Another transition rate with a different shape
hr_S1         = rlnorm(n_sims, log(3), 0.2),      # Hazard ratio, log-normal to allow skewness
hr_S2         = rlnorm(n_sims, log(10), 0.2),     # Higher hazard ratio, same distribution
hr_S1S2_trtB  = rbeta(n_sims, 6, 4),              # Hazard ratio under treatment with beta distribution
r_S1S2_scale  = rgamma(n_sims, shape = 2, rate = 25), # Scale parameter, gamma distribution
r_S1S2_shape  = rgamma(n_sims, shape = 3, rate = 3),  # Shape parameter, gamma distribution
c_H           = rnorm(n_sims, mean = 2000, sd = 50),   # Annual cost, slight variation for simulation
c_S1          = rnorm(n_sims, mean = 4000, sd = 100),  # Higher annual cost, slightly varied
c_S2          = rnorm(n_sims, mean = 15000, sd = 500), # Large cost with moderate variation
c_D           = 0,                                        # Constant, no variation
c_trtA        = rnorm(n_sims, mean = 12000, sd = 200), # Cost of treatment A with small variation
c_trtB        = rnorm(n_sims, mean = 13000, sd = 200), # Cost of treatment B
u_H           = rbeta(n_sims, 10, 1),                  # Utility close to 1 for Healthy
u_S1          = rbeta(n_sims, 7.5, 2.5),               # Utility less than Healthy, beta distribution
u_S2          = rbeta(n_sims, 5, 5),                   # Utility for Sicker
u_D           = 0,                                        # Utility for Dead is constant
u_trtA        = rbeta(n_sims, 9.5, 1),                 # Utility with treatment A, close to Healthy
du_HS1        = rnorm(n_sims, mean = 0.01, sd = 0.005), # Disutility with slight variation
ic_HS1        = rnorm(n_sims, mean = 1000, sd = 100),   # Cost increase with transition
ic_D          = rnorm(n_sims, mean = 2000, sd = 100),    # Cost increase when dying
p0_H          = rbeta(n_sims, 1, 9)                   # Initial probability of being Healthy
)
n_cycles <- 5
mytwig <- twig() +
decisions(names = c(StandardOfCare, StrategyA, StrategyB, StrategyAB)) + # define decisions
states(names = c(H, S1, S2, D), # Markov state names
init_probs = c(1,0,0,0), # everyone starts at H
max_cycles = c(1,n_cycles, 1, 1)) + # the cohort can stay in S1 for n_cycles
event(name = death_event,  # first event is death
options = c(yes,none), # which 2 options
probs = c(pDie, leftover), # probability function name and its complement
transitions = c(D, second_event)) + # if death occurs go to D, otherwise, go to the next event (second_event)
event(name = second_event, # the second event
options = c(recover, getsick, progress, none), # has 4 options
probs = c(pRecover, pGetSick, pProgress, leftover), # and 3 named probabilities and a complement
transitions = c(H, S1, S2, stay)) + # resulting in transitions to H, S1, S2 or else staying in the original state
payoffs(names = c(cost, utility), # payoff names
discount_rates = c(0.03, 0.03)) # payoff discount rates
results <- run_twig(twig_obj = mytwig, params = params, n_cycles = n_cycles, parallel = TRUE)
results$Rewards_summary
calculate_icers(results$Rewards_summary)
plot_ceac(results$Rewards_sim, wtp_range = seq(0, 100000, by = 1000))
