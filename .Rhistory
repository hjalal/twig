getDTthreads(verbose = T)
setDTthreads(threads = 6)
getDTthreads(verbose = T)
setDTthreads(threads = 1)
getDTthreads(verbose = T)
# test advanced markov model
rm(list = ls())
library(gmod)
library(magrittr)
library(data.table)
getDTthreads(verbose = T)
setDTthreads(threads = 1)
params <- list(
### Transition rates (annual), and hazard ratios (HRs) ----
r_HS1  = 0.15,  # constant annual rate of becoming Sick when Healthy
r_S1H  = 0.5 ,  # constant annual rate of becoming Healthy when Sick
hr_S1  = 3   ,  # hazard ratio of death in Sick vs Healthy
hr_S2  = 10  ,  # hazard ratio of death in Sicker vs Healthy
### Effectiveness of treatment B ----
hr_S1S2_trtB = 0.6,  # hazard ratio of becoming Sicker when Sick under treatment B
#* Weibull parameters for state-residence-dependent transition probability of
#* becoming Sicker when Sick conditional on surviving
r_S1S2_scale = 0.08, # scale
r_S1S2_shape = 1.1 , # shape
### State rewards ----
#### Costs ----
c_H    = 2000 , # annual cost of being Healthy
c_S1   = 4000 , # annual cost of being Sick
c_S2   = 15000, # annual cost of being Sicker
c_D    = 0    , # annual cost of being dead
c_trtA = 12000, # annual cost of receiving treatment A
c_trtB = 13000, # annual cost of receiving treatment B
#### Utilities ----
u_H    = 1   ,  # annual utility of being Healthy
u_S1   = 0.75,  # annual utility of being Sick
u_S2   = 0.5 ,  # annual utility of being Sicker
u_D    = 0   ,  # annual utility of being dead
u_trtA = 0.95,  # annual utility when receiving treatment A
### Transition rewards ----
du_HS1 = 0.01,  # disutility when transitioning from Healthy to Sick
ic_HS1 = 1000,  # increase in cost when transitioning from Healthy to Sick
ic_D   = 2000  # increase in cost when dying
)
# Number of simulations
n_sim <- 5
# Function to constrain values between 0 and 1
bound_01 <- function(x) pmax(0, pmin(1, x))
# Simulate the data.table
sim_dt <- data.table(
sim = 1:n_sim,
r_HS1  = rnorm(n_sim, mean = params$r_HS1, sd = 0.02),
r_S1H  = rnorm(n_sim, mean = params$r_S1H, sd = 0.05),
hr_S1  = rlnorm(n_sim, meanlog = log(params$hr_S1), sdlog = 0.2),
hr_S2  = rlnorm(n_sim, meanlog = log(params$hr_S2), sdlog = 0.3),
hr_S1S2_trtB = rlnorm(n_sim, meanlog = log(params$hr_S1S2_trtB), sdlog = 0.1),
r_S1S2_scale = rnorm(n_sim, mean = params$r_S1S2_scale, sd = 0.01),
r_S1S2_shape = rnorm(n_sim, mean = params$r_S1S2_shape, sd = 0.05),
c_H    = rnorm(n_sim, mean = params$c_H, sd = 100),
c_S1   = rnorm(n_sim, mean = params$c_S1, sd = 200),
c_S2   = rnorm(n_sim, mean = params$c_S2, sd = 1000),
c_D    = rep(params$c_D, n_sim),
c_trtA = rnorm(n_sim, mean = params$c_trtA, sd = 500),
c_trtB = rnorm(n_sim, mean = params$c_trtB, sd = 500),
u_H    = bound_01(rbeta(n_sim, shape1 = 50, shape2 = 1)),
u_S1   = bound_01(rbeta(n_sim, shape1 = 37.5, shape2 = 12.5)),
u_S2   = bound_01(rbeta(n_sim, shape1 = 25, shape2 = 25)),
u_D    = rep(params$u_D, n_sim),
u_trtA = bound_01(rbeta(n_sim, shape1 = 47.5, shape2 = 2.5)),
du_HS1 = bound_01(rnorm(n_sim, mean = params$du_HS1, sd = 0.005)),
ic_HS1 = rnorm(n_sim, mean = params$ic_HS1, sd = 100),
ic_D   = rnorm(n_sim, mean = params$ic_D, sd = 200)
)
# View the first few rows of the simulated data
head(sim_dt)
colMeans(sim_dt)
n_age_init <- 25 # age at baseline gmod starts at cycle 1 instead of 0 in the tutorial
n_age_max  <- 100 # maximum age of follow up
## Age-dependent mortality rates ----
lt_usa_2015 <- read.csv("~/github/gmod/inst/extdata/LifeTable_USA_Mx_2015.csv") %>%
as.data.table()
#* Extract age-specific all-cause mortality for ages in model time horizon
dt_mort <- lt_usa_2015[Age >= n_age_init & Age <= n_age_max][, .(cycle=Age-n_age_init + 1, r_die = Total)]
# merge all data into a list
list_params <- list(dt_mort = dt_mort,
)
# merge all data into a list
list_params <- list(dt_mort = dt_mort,
sim_dt = sim_dt)
dt_mort
# merge all data into a list
list_params <- list(r_die = dt_mort,
psa_dt = sim_dt)
list_params
pRecover <- function(state, r_S1H){
rRecover <- ifelse(state=="S1", r_S1H, 0)
rate2prob(rRecover)
}
pGetSick <- function(state, r_HS1){
rGetSick <- ifelse(state=="H", r_HS1, 0)
rate2prob(rGetSick)
}
pProgress <- function(state, decision, cycle_in_state, hr_S1S2_trtB, r_S1S2_scale,
r_S1S2_shape){
rProgress<- ifelse(state=="S1",
ifelse(decision %in% c("StrategyB", "StrategyAB"), hr_S1S2_trtB, 1) *
((cycle_in_state*r_S1S2_scale)^r_S1S2_shape -
((cycle_in_state - 1)*r_S1S2_scale)^r_S1S2_shape)
, 0) # else 0
rate2prob(rProgress)
}
pDie <- function(state, cycle, r_HD, hr_S1, hr_S2){
r_HD <- v_r_mort_by_age[cycle]
rDie <- ifelse(state=="H", r_HD,
ifelse(state=="S1", r_HD*hr_S1,
ifelse(state=="S2", r_HD*hr_S2,
ifelse(state=="D", 0, 0))))
rate2prob(rDie)
}
x <- data.table(a = 1:10, b = 11:20)
x
f <- function(a) a^2
x[,d = f(a)]
x[,d := f(a)]
x
x[,d := do.call(f, .SD), .SDcols = c("a","b")]
f <- function() a^2
x[,d := do.call(f, .SD)]
x[,d := do.call(f)]
x[,d := f()]
f <- function(a) a^2 + b
x[,d := f()]
x[,d := f(f, list(.SD))]
x <- data.table(a = 1:10, b = 11:20)
f <- function(a) a^2 + b
x[,d := f(f, list(.SD))]
x <- data.table(a = 1:10, b = 11:20)
f <- function(...) a^2 + b
x[,d := f(f, list(.SD))]
x[,d := f(f, list(.SD)), .SDcols = c("a", "b")]
x <- data.table(a = 1:10, b = 11:20)
f <- function(...) a^2 + b
x[,d := f(f, list(.SD)), .SDcols = c("a", "b")]
x[,d := f(f, .SD), .SDcols = c("a", "b")]
x
f()
f <- function(...){
print(...)
a^2 + b
}
f()
f <- function(...){
args <- list(...)
print(args)
a^2 + b
}
f()
f(d = 1:20)
f <- function(...){
args <- list(...)
list2env(args)
print(args)
a^2 + b
}
f(d = 1:20)
x[,d := f(f, .SD), .SDcols = c("a", "b")]
x[,d := do.call(f, .SD), .SDcols = c("a", "b")]
f <- function(...){
args <- list(...)
list2env(args, envir = environment())
print(args)
a^2 + b
}
x[,d := do.call(f, .SD), .SDcols = c("a", "b")]
x
dt_mort
I
J
# merge all data into a list
list_params <- list(r_die = dt_mort,
psa_dt = sim_dt)
list_params
str(list_params)
# Get the column names for each data.table in the list
params_names_list <- lapply(dt_list, colnames)
# Get the column names for each data.table in the list
params_names_list <- lapply(list_params, colnames)
params_names_list
filter_columns <- c("r_die", "c_H", "u_H")
# Get the filtered column names for each data.table in the list
filtered_column_names <- lapply(params_names_list, function(dt) {
intersect(colnames(dt), filter_columns)
})
filtered_column_names
# Get the filtered column names for each data.table in the list
filtered_column_names <- lapply(list_params, function(dt) {
intersect(colnames(dt), filter_columns)
})
filtered_column_names
install.packages("twig")
??twig
library(twig)
library(twig)
library(twig)
pkgdown::init_site()
pckgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
library(twig)
library(twig)
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
library(twig)
pkgdown::build_site()
library(gmod)
library(twig)
detach("package:twig", unload = TRUE)
library(twig)
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
# library(data.table)
# setDTthreads(9)
# getDTthreads()
# library(progress)
# ==============
#remove.packages("twig")
# Or more practically, set to your terminal width
options(width = 1000)  # adjust number as needed
devtools::document(roclets = c('rd', 'collate', 'namespace'))
devtools::build(vignettes = FALSE)
# global parameter
rm(list = ls())
# Markov model example ===========
n_sims <- 5
n_cycles <- 10
#library(data.table)
source("sandbox/twig_internal_functions.R")
source("sandbox/test_markov.R")
source("sandbox/get_function_arrays.R")
str(twig_env)
twig_env$layers
# get the function arrays
get_function_arrays(twig_env = twig_env, n_cycles = n_cycles, n_sims = n_sims, params = params)
twig_env$fun_eval_list
twig_env$twig_funs
twig_env$str_fun_array_list
twig_env$fun_args
twig_env$fun_arg_values
twig_env$fun_arg_value_sizes
twig_build(twig_env) #, n_cycles)
get_events_df(twig_env)
add_payoffs(twig_env)
twig_env$fun_eval_list
twig_env$fun_args
twig_env$twig_funs
twig_env$payoff_names
twig_env$fun_args_expanded
add_payoffs <- function(twig_env){
payoffs_layer <- retrieve_layer_by_type(twig_env, type = "payoffs")
twig_env$payoff_names <- payoffs_layer$payoffs
twig_env$n_payoffs <- length(twig_env$payoffs)
twig_env$discounts <- payoffs_layer$discount_rates
twig_env$prob_funs <- twig_env$twig_funs[!twig_env$twig_funs %in% twig_env$payoff_names]
}
add_payoffs(twig_env)
twig_env
twig_env$prob_funs
twig_env
twig_env$fun_args
twig_env$fun_args_expanded
twig_env$fun_args_expanded[twig_env$prob_funs]
twig_env$prob_fun_args_expanded <- twig_env$fun_args_expanded[twig_env$prob_funs]
twig_env$prob_fun_args_expanded
unlist(twig_env$prob_fun_args_expanded)
unique(unlist(twig_env$prob_fun_args_expanded))
twig_env$is_cycle_dep <- "cycle" %in% unique(unlist(twig_env$prob_fun_args_expanded))
twig_env$is_cycle_dep
add_prob_funs <- function(twig_env){
twig_env$prob_funs <- twig_env$twig_funs[!twig_env$twig_funs %in% twig_env$payoff_names]
twig_env$prob_fun_args_expanded <- twig_env$fun_args_expanded[twig_env$prob_funs]
twig_env$is_cycle_dep <- "cycle" %in% unique(unlist(twig_env$prob_fun_args_expanded))
}
add_prob_funs(twig_env)
twig_env$is_cycle_dep
twig_env$prob_fun_args_expanded
source("sandbox/twig_internal_functions.R")
source("sandbox/test_markov.R")
source("sandbox/get_function_arrays.R")
str(twig_env)
twig_env$layers
# get the function arrays
get_function_arrays(twig_env = twig_env, n_cycles = n_cycles, n_sims = n_sims, params = params)
twig_env$fun_eval_list
twig_env$twig_funs
twig_env$str_fun_array_list
twig_env$fun_args
twig_env$fun_arg_values
twig_env$fun_arg_value_sizes
add_payoffs(twig_env)
add_prob_funs(twig_env)
twig_env$is_cycle_dep
twig_env$prob_fun_args_expanded
twig_env$is_cycle_dep <- is_cycle_dep(twig_env)
get_events_df(twig_env)
twig_env$events_df
twig_env$events_df
events_df
# building transition prob matrix logic =======
get_events_df <- function(twig_env){
event_layers <- retrieve_layer_by_type(twig_env, type = "event")
events_df_list <- list()
i <- 0
for (event_layer in event_layers){
i <- i + 1
temp_df <- as.data.frame(event_layers[[i]])
temp_df$values <- as.character(temp_df$values)
# # process payoffs separately for each layer
# payoffs_string <- event_layers[[i]]$payoffs
# if (payoffs_string == ""){
#   # empty string
# } else {
#   payoffs <- payoff2liststring(payoffs_string)
#   for (payoff_name in payoffs){
#     temp_df[[names(payoff_name)]] <- payoff_name
#   }
# }
events_df_list[[i]] <- temp_df
}
events_df <- do.call(rbind, events_df_list)
# replace # with (1-sum(other_probs))
#events_df <- replace_hash_with_complement(events_df)
events_df$id <- seq_len(nrow(events_df))
# return things to twig_env
twig_env$events <- unique(events_df$event)
twig_env$n_events <- length(twig_env$events)
twig_env$events_df <- events_df
twig_env$first_event <- get_first_event(events_df)
}
debugSource("~/github/twig/R/functions_prob_chain_from_events.R", echo=TRUE)
source("~/github/twig/R/functions_prob_chain_from_events.R", echo=TRUE)
events_df <- twig_env$events_df
events_df
twig_env$events
length(unique(events_df$event))
# return a list of event_ids and their complements
compl_id <- events_df$id[events_df$probs == hash_string]
# return a list of event_ids and their complements
hash_string <- "\"#\""
compl_id <- events_df$id[events_df$probs == hash_string]
event_layers <- retrieve_layer_by_type(twig_env, type = "event")
events_df_list <- list()
i <- 0
for (event_layer in event_layers){
i <- i + 1
temp_df <- as.data.frame(event_layers[[i]])
temp_df$values <- as.character(temp_df$values)
# # process payoffs separately for each layer
# payoffs_string <- event_layers[[i]]$payoffs
# if (payoffs_string == ""){
#   # empty string
# } else {
#   payoffs <- payoff2liststring(payoffs_string)
#   for (payoff_name in payoffs){
#     temp_df[[names(payoff_name)]] <- payoff_name
#   }
# }
events_df_list[[i]] <- temp_df
}
events_df <- do.call(rbind, events_df_list)
# replace # with (1-sum(other_probs))
#events_df <- replace_hash_with_complement(events_df)
events_df$id <- seq_len(nrow(events_df))
# return things to twig_env
twig_env$events <- unique(events_df$event)
twig_env$n_events <- length(twig_env$events)
twig_env$events_df <- events_df
twig_env$first_event <- get_first_event(events_df)
events_df
# return a list of event_ids and their complements
hash_string <- "\"#\""
compl_id <- events_df$id[events_df$probs == hash_string]
compl_id
twig_env$compl_id <- compl_id
compl_ids <- list()
i <- 1
i
events_df$event[compl_ids[i]]
events_df$event[compl_id[i]]
events_df$id[compl_id[i]]
events_df$event[compl_id[i]] & events_df$id != events_df$id[compl_id[i]]
events_df$event == events_df$event[compl_id[i]] & events_df$id != events_df$id[compl_id[i]]
events_df$id[events_df$event == events_df$event[compl_id[i]] & events_df$id != events_df$id[compl_id[i]]]
# return a list of event_ids and their complements
hash_string <- "\"#\""
twig_env$hash_id <- hash_id <- events_df$id[events_df$probs == hash_string]
hash_ids <- list()
for (i in 1:length(unique(events_df$event))){
hash_ids[[i]] <- events_df$id[events_df$event == events_df$event[hash_id[i]] & events_df$id != events_df$id[hash_id[i]]]
}
twig_env$compl_ids <- compl_ids
compl_ids
twig_env$hash_id <- hash_id <- events_df$id[events_df$probs == hash_string]
compl_ids <- list()
for (i in 1:length(unique(events_df$event))){
compl_ids[[i]] <- events_df$id[events_df$event == events_df$event[hash_id[i]] & events_df$id != events_df$id[hash_id[i]]]
}
twig_env$compl_ids <- compl_ids
compl_ids
devtools::document(roclets = c('rd', 'collate', 'namespace'))
devtools::build(vignettes = FALSE)
# "/Users/hjalal/github/twig_0.0.1.0.tar.gz"
# global parameter
rm(list = ls())
# Markov model example ===========
n_sims <- 5
n_cycles <- 10
#library(data.table)
source("sandbox/twig_internal_functions.R")
source("sandbox/test_markov.R")
source("sandbox/get_function_arrays.R")
str(twig_env)
twig_env$layers
# get the function arrays
get_function_arrays(twig_env = twig_env, n_cycles = n_cycles, n_sims = n_sims, params = params)
twig_env$fun_eval_list
twig_env$twig_funs
twig_env$str_fun_array_list
twig_env$fun_args
twig_env$fun_arg_values
twig_env$fun_arg_value_sizes
add_payoffs(twig_env)
add_prob_funs(twig_env)
twig_env$is_cycle_dep
twig_env$prob_fun_args_expanded
twig_env$is_cycle_dep <- is_cycle_dep(twig_env)
get_events_df(twig_env)
twig_env$events_df
twig_env$compl_ids
twig_env$hash_id
twig_env$fun_eval_list
# get the function arrays
get_function_arrays(twig_env = twig_env, n_cycles = n_cycles, n_sims = n_sims, params = params)
#library(data.table)
source("sandbox/twig_internal_functions.R")
source("sandbox/test_markov.R")
source("sandbox/get_function_arrays.R")
str(twig_env)
twig_env$layers
# get the function arrays
get_function_arrays(twig_env = twig_env, n_cycles = n_cycles, n_sims = n_sims, params = params)
# get the function arrays
get_function_arrays(twig_env = twig_env, n_cycles = n_cycles, n_sims = n_sims, params = params)
twig_env$list_evaluated_funs
n_sims <- 2
n_cycles <- 3
#library(data.table)
source("sandbox/twig_internal_functions.R")
source("sandbox/test_markov.R")
source("sandbox/get_function_arrays.R")
str(twig_env)
twig_env$layers
# get the function arrays
get_function_arrays(twig_env = twig_env, n_cycles = n_cycles, n_sims = n_sims, params = params)
twig_env$list_evaluated_funs
# get the function arrays
get_function_arrays(twig_env = twig_env, n_cycles = n_cycles, n_sims = n_sims, params = params)
twig_env$list_evaluated_funs
twig_env$twig_funs
twig_env$str_fun_array_list
twig_env$fun_args
twig_env$fun_arg_values
twig_env$fun_arg_value_sizes
add_payoffs(twig_env)
add_prob_funs(twig_env)
twig_env$is_cycle_dep
twig_env$prob_fun_args_expanded
get_events_df(twig_env)
twig_env$events_df
twig_env$hash_id
twig_env$compl_ids
twig_env$events_df
twig_env$prob_fun_args_expanded
# global parameter
rm(list = ls())
# Markov model example ===========
n_sims <- 2
n_cycles <- 3
#library(data.table)
#source("sandbox/twig_internal_functions.R")
source("sandbox/test_markov.R")
# Specify the path to the "functions" folder
functions_folder <- "sandbox/functions"
# List all .R files in the folder
function_files <- list.files(functions_folder, pattern = "\\.R$", full.names = TRUE)
# Source each file
sapply(function_files, source)
#library(data.table)
#source("sandbox/twig_internal_functions.R")
source("sandbox/test_markov.R")
twig_obj
#library(data.table)
#source("sandbox/twig_internal_functions.R")
source("sandbox/test_markov.R")
twig_obj
