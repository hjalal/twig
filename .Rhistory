options = c(yes,none), # which 2 options
probs = c(pDie, leftover), # probability function name and its complement
transitions = c(D, second_event)) + # if death occurs go to D, otherwise, go to the next event (second_event)
event(name = second_event, # the second event
options = c(recover, getsick, progress, none), # has 4 options
probs = c(pRecover, pGetSick, pProgress, leftover), # and 3 named probabilities and a complement
transitions = c(H, S1, S2, stay)) + # resulting in transitions to H, S1, S2 or else staying in the original state
payoffs(names = c(cost, utility), # payoff names
discount_rates = c(0.03, 0.03)) # payoff discount rates
n_sims <- 1000
# Create the data.table with n_sim rows of random samples
params <- data.frame(
r_HS1         = rbeta(n_sims, 2, 10),             # Transition rate with beta distribution
r_S1H         = rbeta(n_sims, 5, 5),              # Another transition rate with a different shape
hr_S1         = rlnorm(n_sims, log(3), 0.2),      # Hazard ratio, log-normal to allow skewness
hr_S2         = rlnorm(n_sims, log(10), 0.2),     # Higher hazard ratio, same distribution
hr_S1S2_trtB  = rbeta(n_sims, 6, 4),              # Hazard ratio under treatment with beta distribution
r_S1S2_scale  = rgamma(n_sims, shape = 2, rate = 25), # Scale parameter, gamma distribution
r_S1S2_shape  = rgamma(n_sims, shape = 3, rate = 3),  # Shape parameter, gamma distribution
c_H           = rnorm(n_sims, mean = 2000, sd = 50),   # Annual cost, slight variation for simulation
c_S1          = rnorm(n_sims, mean = 4000, sd = 100),  # Higher annual cost, slightly varied
c_S2          = rnorm(n_sims, mean = 15000, sd = 500), # Large cost with moderate variation
c_D           = 0,                                        # Constant, no variation
c_trtA        = rnorm(n_sims, mean = 12000, sd = 200), # Cost of treatment A with small variation
c_trtB        = rnorm(n_sims, mean = 13000, sd = 200), # Cost of treatment B
u_H           = rbeta(n_sims, 10, 1),                  # Utility close to 1 for Healthy
u_S1          = rbeta(n_sims, 7.5, 2.5),               # Utility less than Healthy, beta distribution
u_S2          = rbeta(n_sims, 5, 5),                   # Utility for Sicker
u_D           = 0,                                        # Utility for Dead is constant
u_trtA        = rbeta(n_sims, 9.5, 1),                 # Utility with treatment A, close to Healthy
du_HS1        = rnorm(n_sims, mean = 0.01, sd = 0.005), # Disutility with slight variation
ic_HS1        = rnorm(n_sims, mean = 1000, sd = 100),   # Cost increase with transition
ic_D          = rnorm(n_sims, mean = 2000, sd = 100),    # Cost increase when dying
p0_H          = rbeta(n_sims, 1, 9)                   # Initial probability of being Healthy
)
pRecover <- function(state, r_S1H){
rRecover <- r_S1H * (state=="S1")
rate2prob(rRecover)
}
pGetSick <- function(state, r_HS1){
rGetSick <- r_HS1 * (state=="H")
rate2prob(rGetSick)
}
pProgress <- function(state, decision, cycle_in_state,
hr_S1S2_trtB, r_S1S2_scale, r_S1S2_shape){
hr_S1S2 <- hr_S1S2_trtB ^ (decision %in% c("StrategyB", "StrategyAB")) # hazard rate of progression for B or 1 otherwise
r_S1S2_tunnels <- ((cycle_in_state*r_S1S2_scale)^r_S1S2_shape -
((cycle_in_state - 1)*r_S1S2_scale)^r_S1S2_shape) # hazard rate based on cycle_in_state (tunnel) which follows a weibull distribution
# only those who are at S1 can progress
rProgress <- r_S1S2_tunnels * (state=="S1") * hr_S1S2
rate2prob(rProgress)
}
n_age_init <- 24 # starting age
n_age_max  <- 100 # maximum age of simulation
# Age-dependent mortality rates
lt_usa_2015 <- read.csv("../inst/extdata/LifeTable_USA_Mx_2015.csv")
# choose mortality rates from the
v_r_mort_by_age <- as.matrix(lt_usa_2015$Total[lt_usa_2015$Age >= n_age_init & lt_usa_2015$Age < n_age_max])
# death depends on the state and age.
pDie <- function(state, cycle,
hr_S1, hr_S2){
r_HD <- v_r_mort_by_age[cycle] # get age-specific mortality
rDie <- r_HD * (state=="H") +  # baseline mortality if healthy
r_HD*hr_S1 * (state=="S1") +  # multiplied by a hazard rate if S1 or
r_HD*hr_S2 * (state=="S2") # S2
# else 0
rate2prob(rDie)
}
cost <- function(state, decision, second_event, death_event,
ic_HS1, ic_D, c_trtA, c_trtB,
c_H, c_S1, c_S2, c_D){
# cost of decision is only applied if the state is either S1 or S2
trans_cost_getting_sick <- ic_HS1 * (second_event=="getsick") # increase in cost when transitioning from Healthy to Sick
trans_cost_dying <- ic_D * (death_event=="yes") # increase in cost when dying
c_decision <- (state %in% c("S1","S2")) * (
c_trtA * (decision=="StrategyA") +
c_trtB * (decision=="StrategyB") +
(c_trtA + c_trtB) * (decision=="StrategyAB")
)
# cost of the state is a function of the state
c_state <- c_H * (state=="H") +
c_S1 * (state=="S1") +
c_S2 * (state=="S2") +
c_D * (state=="D")
# combine both
return(c_decision + c_state + trans_cost_getting_sick + trans_cost_dying)
}
utility <- function(state, decision, second_event,
du_HS1, u_H, u_trtA, u_S1, u_S2, u_D){
trans_util_getting_sick <- -du_HS1 * (second_event=="getsick") # apply a utility discount for those who get sick.
# calcualte state utilities. note that S1 will have utility u_trtA if the decision involves A, and another utility if the decision does not involve A.
u_state <- u_H * (state=="H") +
u_trtA * (state=="S1" & decision %in% c("StrategyA", "StrategyAB")) +
u_S1 * (state=="S1" & decision %out% c("StrategyA", "StrategyAB")) +
u_S2 * (state=="S2") +
u_D * (state=="D")
# combine the two utilities.
return(u_state + trans_util_getting_sick)
}
results <- run_twig(twig_obj = mytwig, params = params, n_cycles = n_cycles, progress_bar = FALSE, verbose = TRUE)
results$mean_ev
calculate_icers(results$mean_ev)
results$sim_ev
plot_ceac(results$sim_ev, wtp_range = seq(0, 100000, by = 1000))
rewards_sim
str(results)
results <- run_twig(twig_obj = mytwig, params = params, n_cycles = n_cycles, progress_bar = FALSE, verbose = F)
results$mean_ev
calculate_icers(results$mean_ev)
plot_ceac(results$sim_ev, wtp_range = seq(0, 100000, by = 1000))
library(twig)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
rm(list = ls())
options(width = 200)
library(twig)
n_cycles <- 25 # number of cycles
mytwig <- twig() +
decisions(names = c(StandardOfCare, StrategyA, StrategyB, StrategyAB)) + # define decisions
states(names = c(H, S1, S2, D), # Markov state names
init_probs = c(1,0,0,0), # everyone starts at H
max_cycles = c(1,n_cycles, 1, 1)) + # the cohort can stay in S1 for n_cycles
event(name = death_event,  # first event is death
options = c(yes,none), # which 2 options
probs = c(pDie, leftover), # probability function name and its complement
transitions = c(D, second_event)) + # if death occurs go to D, otherwise, go to the next event (second_event)
event(name = second_event, # the second event
options = c(recover, getsick, progress, none), # has 4 options
probs = c(pRecover, pGetSick, pProgress, leftover), # and 3 named probabilities and a complement
transitions = c(H, S1, S2, stay)) + # resulting in transitions to H, S1, S2 or else staying in the original state
payoffs(names = c(cost, utility), # payoff names
discount_rates = c(0.03, 0.03)) # payoff discount rates
n_sims <- 1000
# Create the data.table with n_sim rows of random samples
params <- data.frame(
r_HS1         = rbeta(n_sims, 2, 10),             # Transition rate with beta distribution
r_S1H         = rbeta(n_sims, 5, 5),              # Another transition rate with a different shape
hr_S1         = rlnorm(n_sims, log(3), 0.2),      # Hazard ratio, log-normal to allow skewness
hr_S2         = rlnorm(n_sims, log(10), 0.2),     # Higher hazard ratio, same distribution
hr_S1S2_trtB  = rbeta(n_sims, 6, 4),              # Hazard ratio under treatment with beta distribution
r_S1S2_scale  = rgamma(n_sims, shape = 2, rate = 25), # Scale parameter, gamma distribution
r_S1S2_shape  = rgamma(n_sims, shape = 3, rate = 3),  # Shape parameter, gamma distribution
c_H           = rnorm(n_sims, mean = 2000, sd = 50),   # Annual cost, slight variation for simulation
c_S1          = rnorm(n_sims, mean = 4000, sd = 100),  # Higher annual cost, slightly varied
c_S2          = rnorm(n_sims, mean = 15000, sd = 500), # Large cost with moderate variation
c_D           = 0,                                        # Constant, no variation
c_trtA        = rnorm(n_sims, mean = 12000, sd = 200), # Cost of treatment A with small variation
c_trtB        = rnorm(n_sims, mean = 13000, sd = 200), # Cost of treatment B
u_H           = rbeta(n_sims, 10, 1),                  # Utility close to 1 for Healthy
u_S1          = rbeta(n_sims, 7.5, 2.5),               # Utility less than Healthy, beta distribution
u_S2          = rbeta(n_sims, 5, 5),                   # Utility for Sicker
u_D           = 0,                                        # Utility for Dead is constant
u_trtA        = rbeta(n_sims, 9.5, 1),                 # Utility with treatment A, close to Healthy
du_HS1        = rnorm(n_sims, mean = 0.01, sd = 0.005), # Disutility with slight variation
ic_HS1        = rnorm(n_sims, mean = 1000, sd = 100),   # Cost increase with transition
ic_D          = rnorm(n_sims, mean = 2000, sd = 100),    # Cost increase when dying
p0_H          = rbeta(n_sims, 1, 9)                   # Initial probability of being Healthy
)
pRecover <- function(state, r_S1H){
rRecover <- r_S1H * (state=="S1")
rate2prob(rRecover)
}
pGetSick <- function(state, r_HS1){
rGetSick <- r_HS1 * (state=="H")
rate2prob(rGetSick)
}
pProgress <- function(state, decision, cycle_in_state,
hr_S1S2_trtB, r_S1S2_scale, r_S1S2_shape){
hr_S1S2 <- hr_S1S2_trtB ^ (decision %in% c("StrategyB", "StrategyAB")) # hazard rate of progression for B or 1 otherwise
r_S1S2_tunnels <- ((cycle_in_state*r_S1S2_scale)^r_S1S2_shape -
((cycle_in_state - 1)*r_S1S2_scale)^r_S1S2_shape) # hazard rate based on cycle_in_state (tunnel) which follows a weibull distribution
# only those who are at S1 can progress
rProgress <- r_S1S2_tunnels * (state=="S1") * hr_S1S2
rate2prob(rProgress)
}
n_age_init <- 24 # starting age
n_age_max  <- 100 # maximum age of simulation
# Age-dependent mortality rates
lt_usa_2015 <- read.csv("../inst/extdata/LifeTable_USA_Mx_2015.csv")
# choose mortality rates from the
v_r_mort_by_age <- as.matrix(lt_usa_2015$Total[lt_usa_2015$Age >= n_age_init & lt_usa_2015$Age < n_age_max])
# death depends on the state and age.
pDie <- function(state, cycle,
hr_S1, hr_S2){
r_HD <- v_r_mort_by_age[cycle] # get age-specific mortality
rDie <- r_HD * (state=="H") +  # baseline mortality if healthy
r_HD*hr_S1 * (state=="S1") +  # multiplied by a hazard rate if S1 or
r_HD*hr_S2 * (state=="S2") # S2
# else 0
rate2prob(rDie)
}
cost <- function(state, decision, second_event, death_event,
ic_HS1, ic_D, c_trtA, c_trtB,
c_H, c_S1, c_S2, c_D){
# cost of decision is only applied if the state is either S1 or S2
trans_cost_getting_sick <- ic_HS1 * (second_event=="getsick") # increase in cost when transitioning from Healthy to Sick
trans_cost_dying <- ic_D * (death_event=="yes") # increase in cost when dying
c_decision <- (state %in% c("S1","S2")) * (
c_trtA * (decision=="StrategyA") +
c_trtB * (decision=="StrategyB") +
(c_trtA + c_trtB) * (decision=="StrategyAB")
)
# cost of the state is a function of the state
c_state <- c_H * (state=="H") +
c_S1 * (state=="S1") +
c_S2 * (state=="S2") +
c_D * (state=="D")
# combine both
return(c_decision + c_state + trans_cost_getting_sick + trans_cost_dying)
}
utility <- function(state, decision, second_event,
du_HS1, u_H, u_trtA, u_S1, u_S2, u_D){
trans_util_getting_sick <- -du_HS1 * (second_event=="getsick") # apply a utility discount for those who get sick.
# calcualte state utilities. note that S1 will have utility u_trtA if the decision involves A, and another utility if the decision does not involve A.
u_state <- u_H * (state=="H") +
u_trtA * (state=="S1" & decision %in% c("StrategyA", "StrategyAB")) +
u_S1 * (state=="S1" & decision %out% c("StrategyA", "StrategyAB")) +
u_S2 * (state=="S2") +
u_D * (state=="D")
# combine the two utilities.
return(u_state + trans_util_getting_sick)
}
results <- run_twig(twig_obj = mytwig, params = params, n_cycles = n_cycles, progress_bar = FALSE, verbose = F)
results$mean_ev
str(results)
results <- run_twig(twig_obj = mytwig, params = params, n_cycles = n_cycles, progress_bar = FALSE, verbose = T)
results$mean_ev
str(results)
rm(list = ls())
options(width = 200)
library(twig)
results <- run_twig(twig_obj = mytwig, params = params, parallel = FALSE, progress_bar = FALSE, verbose = TRUE)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
rm(list = ls())
options(width = 200)
library(twig)
mytwig <- twig() +
decisions(names=c(DoNotTreat, Treat, Biopsy)) +  # treatment options
event(name = DIE,  # first event
options = c(yes, none), # either occurs or doesn't occur
probs = c(pDie, leftover),  # occurs with prob pDie and doesn't occur with 1-pDie (leftover)
transitions = c(Death, HVE_event)) + # if it occurs, transitions to Death, otherwise the HVE_event
event(name = HVE_event,  # similarly, HVE_event occurs with f_HVE but if not it will be OVE
options = c(yes, none),
probs = c(f_HVE, leftover),
transitions = c(get_HVE_comp, get_OVE_comp)) +
event(name = get_HVE_comp, # evaluate whether HVE complications occured
options = c(yes, none),
probs = c(p_comp, leftover),
transitions = c(HVE_comp, no_HVE_comp))  +
event(name = get_OVE_comp, # evaluate whether other viral encephalitis (OVE) complications occured
options = c(yes, none),
probs = c(p_comp, leftover),
transitions = c(OVE_comp, no_OVE_comp)) +
payoffs(names = c(cost, utility)) # finally measure the cost and utilities
params <- list(
# Probabilities,
p_HVE          = 0.52   ,# prevalence of HVE
p_HVE_comp     = 0.71   ,# complications with untreated HVE
p_OVE_comp     = 0.01   ,# complications with untreated OVE
p_HVE_comp_tx  = 0.36   ,# complications with treated HVE
p_OVE_comp_tx  = 0.20   ,# complications with treated OVE
p_biopsy_death = 0.005  ,# probability of death due to biopsy
# Costs,
c_VE           = 1200   ,# cost of viral encephalitis care without complications
c_VE_comp      = 9000   ,# cost of viral encephalitis care with complications
c_tx           = 9500   ,# cost of treatment
c_biopsy       = 25000  ,# cost of brain biopsy
# QALYs,
q_VE           = 20     ,# remaining QALYs for those without VE-related complications
q_VE_comp      = 19     ,# remaining QALYs for those with VE-related complications
q_loss_biopsy  = 0.01   ,# one-time QALY loss due to brain biopsy
q_death_biopsy = 0      # remaining QALYs for those who died during biopsy
)
pDie <- function(decision, p_biopsy_death){
p_biopsy_death * (decision == "Biopsy")
}
p_comp <- function(decision, HVE_event, p_HVE_comp, p_OVE_comp,
p_HVE_comp_tx, p_OVE_comp_tx) {
# complication of untreated HVE
p_HVE_comp * (decision == "DoNotTreat" & HVE_event=="yes") +
# complication of untreated OVE
p_OVE_comp * (decision %in% c("DoNotTreat", "Biopsy") & HVE_event=="none") +
# complications of treated HVE
p_HVE_comp_tx * (decision %in% c("Treat", "Biopsy") & HVE_event=="yes") +
# complications of treated OVE
p_OVE_comp_tx * (decision == "Treat" & HVE_event=="none")
}
f_HVE <- function(p_HVE){
p_HVE
}
cost <- function(decision, outcome, c_biopsy, c_tx, c_VE_comp, c_VE){
# cost of biopsy
c_biopsy*(decision=="Biopsy") +
# cost of treatment if treated or biopsy was +ve for HVE
c_tx*(decision=="Treat" | (decision=="Biopsy" & outcome %in% c("HVE_comp", "no_HVE_comp"))) +
# cost of complication if outcomes are in either HVE or OVE complications
c_VE_comp*(outcome %in% c("HVE_comp", "OVE_comp")) +
# cost of viral encephalitis if complications didn't occur
c_VE*(outcome %in% c("no_HVE_comp", "no_OVE_comp"))
}
utility <- function(decision, outcome, q_loss_biopsy, q_VE_comp, q_VE){
# apply utility discount for biopsy
-q_loss_biopsy*(decision=="Biopsy") +
# apply utility values for complications
q_VE_comp*(outcome %in% c("HVE_comp", "OVE_comp")) +
# apply utility values if complications didn't occur
q_VE*(outcome %in% c("no_HVE_comp", "no_OVE_comp"))
}
results <- run_twig(twig_obj = mytwig, params = params, parallel = FALSE, progress_bar = FALSE, verbose = TRUE)
results$sim_ev
str(results)
results <- run_twig(twig_obj = mytwig, params = params, parallel = FALSE, progress_bar = FALSE, verbose = F)
results$sim_ev
results
calculate_icers(results$mean_ev)
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
library(twig)
library(twig)
library(twig)
library(twig)
library(twig)
tinytex::install_tinytex()
update.packages(ask = FALSE)
library(twig)
version
pkgdown::build_site()
library(twig)
mytwig <- twig() +
decisions(names = c("A", "B")) +  # Decision alternatives
states(names = c("Alive", "Dead"),  # Markov state names
init_probs = c(1, 0)) +  # The cohort starts healthy
event(name = "death_event",  # A death event can have
options = c("yes", "none"),  # Two options: "yes" and "none"
probs = c(pDie, leftover),  # Occur with probabilities pDie and leftover = 1 - pDie
transitions=c(Dead,stay)) + # can lead to death state otherwise stay in their current state, respectively
payoffs(names = c(cost, utility))  # will capture the cost and utility
# 1. probability of death is a function of the state, decision and relative risk of mortality given treatment A
pDie <- function(state, decision, rrMortA){
rDie <- 0.2*(state=="Alive") * rrMortA^(decision=="A") # rate of death is 20% if alive, 0 otherwise. This rate is multiplied by rrMortA for A, otherwise 1.
rate2prob(rDie) # convert the rate into probability
}
# 2. cost is a function of the decision
cost <- function(decision, cA, cB){
cA * (decision=="A") +
cB * (decision=="B")
}
# 3. utility is uAlive if alive, otherwise 0
utility <- function(state, uAlive){
uAlive * (state=="Alive")
}
n_sims <- 1000 # number of simulations
psa_params <- data.frame(
rrMortA = rnorm(n_sims, 0.01, 0.001), # Normal: relative risk of mortality
cA = rlnorm(n_sims, 10, 1), # Log-normal: cost of A
cB = rlnorm(n_sims, 12, 1), # Log-normal: cost of B
uAlive = rbeta(n_sims, 0.8, 0.2)) # Beta: utility of being alive
head(psa_params) # examining the first 6 samples
results <- run_twig(twig_obj = mytwig, params = psa_params, n_cycles = 50)
results$mean_ev #average across all simulations
#         reward
# decision      cost  utility
#        A 11943.623 4.666476
#        B  4407.286 3.658201
n_sims <- 10000 # number of simulations
psa_params <- data.frame(
rrMortA = rnorm(n_sims, 0.01, 0.001), # Normal: relative risk of mortality
cA = rlnorm(n_sims, 10, 1), # Log-normal: cost of A
cB = rlnorm(n_sims, 12, 1), # Log-normal: cost of B
uAlive = rbeta(n_sims, 0.8, 0.2)) # Beta: utility of being alive
results <- run_twig(twig_obj = mytwig, params = psa_params, n_cycles = 50)
results$mean_ev #average across all simulations
#         reward
# decision      cost  utility
#        A 11943.623 4.666476
#        B  4407.286 3.658201
calculate_icers(results$mean_ev)
# time-independent Markov model example =================
library(twig)
rm(list = ls())
mytwig <- twig() +
decisions(names=c(A,B)) + # decision alternatives
states(names=c(Alive,Dead), # Markov state names
init_probs=c(1,0)) + # The cohort starts healthy
event(name=death_event, # A death event can occur with
options=c(yes,none),  # 2 options "yes" and "none",
probs=c(pDie,leftover), # that can occur with probabilities pDie and leftover = 1-pDie,
transitions=c(Dead,stay)) + # can lead to death state otherwise stay in their current state
payoffs(names = c(cost, utility))  # will capture the cost and utility
pDie <- function(state, rrMortA){
rDie <- rrMortA * (state=="Alive") # rate of probability increases at 0.01 per cycle (year)
rate2prob(rDie) # convert the rate into probability
}
# 2. cost is a function of the decision
cost <- function(decision, cA, cB){
cA * (decision=="A") +
cB * (decision=="B")
}
# 3. utility is uAlive if alive, otherwise 0
utility <- function(state, uAlive){
uAlive * (state=="Alive")
}
n_sims <- 1000 # number of simulations
psa_params <- data.frame(
rrMortA = rnorm(n_sims, 0.01, 0.001), # relative risk of mortality
cA = rlnorm(n_sims, 10, 1), # cost of A
cB = rlnorm(n_sims, 12, 1), # cost of B
uAlive = rbeta(n_sims, 0.8, 0.2)) # utility of being alive
head(psa_params) # examining the first 6 samples
results <- run_twig(twig_obj = mytwig, params = psa_params, n_cycles = 50, verbose = F, parallel = T)
results$mean_ev
results <- run_twig(twig_obj = mytwig, params = psa_params, n_cycles = 50, verbose = F, parallel = F)
results$mean_ev
calculate_icers(results$mean_ev)
plot_ceac(results$Rewards_sim, wtp_range = seq(0, 100000, by = 1000))
plot_ceac(results$sim_ev, wtp_range = seq(0, 100000, by = 1000))
source("~/Desktop/getting_started.R")
print(results$mean_ev)
print(calculate_icers(results$mean_ev))
plot_ceac(results$sim_ev, wtp_range = seq(0, 100000, by = 1000))
source("~/Desktop/getting_started.R")
source("~/Desktop/getting_started.R")
source("~/Desktop/getting_started.R")
source("~/Desktop/getting_started.R")
source("~/Desktop/getting_started.R")
head(psa_params) # examining the first 6 samples
print(results$mean_ev)
print(calculate_icers(results$mean_ev))
print(plot_ceac(results$sim_ev, wtp_range = seq(0, 100000, by = 1000)))
library(twig)
library(twig)
pkgdown::built_site()
pkgdown::build_site()
library(twig)
library(twig)
mytwig <- twig() +
decisions(names = c("A", "B")) +  # Decision alternatives
states(names = c("Alive", "Dead"),  # Markov state names
init_probs = c(1, 0)) +  # The cohort starts healthy
event(name = "death_event",  # A death event can
options = c("yes", "none"),  # have two options: "yes" and "none",
probs = c(pDie, leftover),  # occur with probabilities: pDie and leftover = 1 - pDie
transitions=c(Dead,stay)) + # can lead to death state otherwise stay in their current state, respectively.
payoffs(names = c(cost, utility))  # Payoff function names
# 1. probability of death is a function of the state, decision and relative risk of mortality given treatment A
pDie <- function(state, decision, rrMortA){
rDie <- 0.01*(state=="Alive") * rrMortA^(decision=="A") # rate of death is 20% if alive, 0 otherwise. This rate is multiplied by rrMortA for A, otherwise 1.
rate2prob(rDie) # convert the rate into probability
}
# 2. cost is a function of the decision
cost <- function(decision, cA, cB){
cA * (decision=="A") +
cB * (decision=="B")
}
# 3. utility is uAlive if alive, otherwise 0
utility <- function(state, uAlive){
uAlive * (state=="Alive")
}
n_sims <- 1000 # number of simulations
psa_params <- data.frame(
rrMortA = rnorm(n_sims, 0.9, 0.1), # Normal: relative risk of mortality
cA = rlnorm(n_sims, 6, 1), # Log-normal: cost of A
cB = rlnorm(n_sims, 5, 1), # Log-normal: cost of B
uAlive = rbeta(n_sims, 0.8, 0.2)) # Beta: utility of being alive
head(psa_params) # examining the first 6 samples
results <- run_twig(twig_obj = mytwig, params = psa_params, n_cycles = 50, verbose = F, parallel = F)
print(results$mean_ev)
print(calculate_icers(results$mean_ev))
print(plot_ceac(results$sim_ev, wtp_range = seq(0, 100000, by = 1000)))
?tidyverse
?ggplot2
library(twig)
pkgdown::build_site()
library(twig)
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
$stdout
$stdout
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
library(twig)
?twig
pkgdown::build_site()
library(twig)
