# creates a list of event_scenario_dt from events_dt.
# not clear how it handles complements
# it also joins the dts may not be necessary.
# update.
join_events_dt <- function(events_dt) {
  result_list <- list()  # To store results of each join
  
  for (i in seq_len(nrow(events_dt))) {
    # Get the corresponding data.table based on the prob column
    dt_name <- dt_fun_list[[events_dt$prob[i]]]
    # Take the current row of events_df
    current_row <- events_dt[i]
    # Add an identifier (like row number) to facilitate joining
    # Perform a Cartesian join by adding the current_row to each row of df_to_join
    joined_dt <- df_to_join[, c(current_row, .SD), .SDcols = names(df_to_join)]
    # Append the result to the list
    result_list[[i]] <- joined_dt
  }
  
  # Combine all the joined results into a single data.table
  result_dt <- rbindlist(result_list, fill = TRUE)
  return(result_dt)
}

# Function to find the common columns except 'p'
find_common_cols <- function(dt_list) {
  # Get common columns other than 'p' for joining
  common_cols <- Reduce(intersect, lapply(dt_list, function(dt) setdiff(names(dt), "p")))
  return(common_cols)
}

# converts fun_dt into event_scenario_dt, including complements
# may want to convert to stacking isntead of joining.
full_join_and_sum <- function(dt_list, complement = TRUE) {
  # Perform full join on all columns except 'p'
  result_dt <- Reduce(function(x, y) {
    join_cols <- intersect(setdiff(names(x), "p"), setdiff(names(y), "p")) # exclude 'p' from join columns
    merge(x, y, by = join_cols, all = TRUE) #, allow.cartesian=TRUE)
  }, dt_list)
  
  # Sum the 'p' columns after joining
  p_cols <- grep("^p", names(result_dt), value = TRUE) # find all 'p' columns
  if(complement){
    result_dt[, p_sum := 1-rowSums(.SD, na.rm = TRUE), .SDcols = p_cols]
  } else {
    result_dt[, p_sum := rowSums(.SD, na.rm = TRUE), .SDcols = p_cols]
  }
  # Remove the 'p' columns
  result_dt[, (p_cols) := NULL]
  setnames(result_dt, "p_sum", "p")
  return(result_dt)
}


return_complement <- function(compl_id){
  event_i <- events_dt[id == compl_id]$event
  p_names <- events_dt[event == event_i & probs != "#"]$probs
  if (length(p_names) == 1){ # just compute complementary
    result_dt <- dt_fun_list[[p_names]] #get(paste0("dt_", p_names))
    result_dt[,p := 1 - p]
  } else { # join, sum and compute complementary
    dt_list <- dt_fun_list[p_names] #mget(paste0("dt_", p_names))
    
    # Call the function with your list of data.tables
    result_dt <- full_join_and_sum(dt_list)
  }
  return(result_dt)
}


# idea to expand the arrays so they all have the same dimenions and 
# adding x
smart_sum <- function(sel_fun_outputs, twig_data){
  # harmonize and join the objects
  joined_datasets <- harmonize_and_join(sel_fun_outputs)
  # stack them
  aggregated_data <- joined_datasets[, .(sum_x = sum(x)), by = unique_cols]
  return(aggregated_data)
  # sum 
}

# doing products by aggregation rather than a join ========
smart_prod <- function(sel_fun_outputs, twig_data){
  # harmonize and join the objects
  joined_datasets <- harmonize_and_join(sel_fun_outputs)
  # stack them
  # conditional product if # is == number of datasets
  # Aggregate to compute product of 'x' only when .N == n_sel_fun_outputs
  aggregated_data <- joined_datasets[, .(x = if (.N == n_sel_fun_outputs) 
    prod(x) else NA_real_), by = unique_cols]
  aggregated_data[!is.na(x)]
  return(aggregated_data)
  # sum 
}


# Function to extract unique components
get_unique_components <- function(sel_arg_values, component) {
  # Extract values for the specified component from all sub-lists
  values <- unlist(lapply(sel_arg_values, function(x) x[[component]]))
  # Get unique values
  unique_values <- unique(values)
  return(unique_values)
}


# getting unique column names other than x from a list of datasets 
get_unique_values <- function(sel_fun_outputs, relevant_columns){
  unique_values <- list()
  for (dataset_name in names(sel_fun_outputs)) {
    dataset <- sel_fun_outputs[[dataset_name]]
    
    # Exclude the 'x' column
    relevant_columns <- setdiff(names(dataset), "x")
    
    for (col in relevant_columns) {
      unique_vals <- unique(dataset[[col]])
      
      if (!is.null(unique_values[[col]])) {
        unique_values[[col]] <- unique(c(unique_values[[col]], unique_vals))
      } else {
        unique_values[[col]] <- unique_vals
      }
    }
    
  }
  return(unique_values)
}

# harmonize and join twig_obj
harmonize_and_join <- function(sel_fun_outputs, twigs_data){
  # Initialize lists to hold unique values
  unique_values <- get_unique_values(sel_fun_outputs)
  
  # Initialize a list to store the joined datasets
  joined_dataset_list <- list()
  unique_cols <- names(unique_values)
  n_sel_fun_outputs <- length(sel_fun_outputs)
  # Iterate through each dataset to perform the cross join
  for (dataset_name in names(sel_fun_outputs)) {
    # only keep datasets with non-zeros
    dataset <- sel_fun_outputs[[dataset_name]][x>0,]
    
    # Determine the columns for the join
    x <- names(dataset)
    y <- c(names(unique_values), "x")
    relevant_columns <- setdiff(y, x)
    shared_columns <- y[y %in% x & y != "x"]
    if (length(relevant_columns) > 0){
      # Create a list to hold data tables for the cross join
      input_list <- unique_values[relevant_columns]
      
      join_data <- do.call(CJ, unique_values)
      join_data <- merge(join_data, dataset, by = shared_columns)
    } else {
      join_data <- dataset
    }
    
    # Store the result in the list
    joined_dataset_list[[dataset_name]] <- join_data
  }
  joined_datasets <- rbindlist(joined_dataset_list, use.names = TRUE)
  return(joined_datasets)
}

